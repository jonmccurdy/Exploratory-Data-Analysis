[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data-210-Book",
    "section": "",
    "text": "Welcome\nWelcome to Exploratory Data Analysis!\nThis online book is designed to guide you step by step as you build both the technical skills and the critical thinking needed to work with data. Along the way, you’ll learn how to ask good questions, organize and analyze information in R, and communicate your findings clearly to others.\nThe chapters are filled with examples, practice problems, and short stories about Emmit — a character you’ll get to know as you apply your skills in fun and practical ways. Each section is scaffolded to help you practice, reflect, and gain confidence as you progress. Additionally, there are downloadable reading guides and activities to assist you in your learning journey.\nWhether you’re brand new to programming, statistics, or data science, or you’ve had some experience before, this book is meant to meet you where you are and help you grow. By the end, you’ll not only understand the concepts but also feel confident using them in real-world situations.\n\nNote\nThis textbook was written by Dr. Jon McCurdy for Mount St. Mary’s University’s Exploratory Data Analysis course. Special Thanks to student Luke Papayoanou for his input along with developing the MSMU package in R to go along with this book.\n\n\n\n\n Dr. Jon McCurdy\n\n\n Luke Papayoanou",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html",
    "href": "Lecture-1-R-Fundamentals-Review.html",
    "title": "1  R Fundamentals Review",
    "section": "",
    "text": "1.1 Using R as a Computer\nThe aim of this lecture is to provide a review of R along with RMarkdown. While you should have seen most of this material before, it will be beneficial to have a refresher. As you go through this lecture write-up, I encourage you to run the code in your own R Console. Once you are comfortable with the material try and make slight change to the code and see how that effects the results. This will help you truly understand what is going on.\nWhen we first started using R, we emphasized thinking of R as a calculator. Any mathematical operation we want to do can most likely be done in R. The code below shows how we can do addition, subtraction, multiplication, and division.\n13 + 29\n\n[1] 42\n\n(4 + 145*2)/(5 + 2^(3 + 1))\n\n[1] 14\nR also supports exponents, modular division using the %% operator (which returns the remainder), and integer division using the %/% operator (which can be thought of as the floor of the division). Below, we can see how these operations are related.\n27/5\n\n[1] 5.4\n\n27 %/% 5 # This gives how many times 5 goes into 27\n\n[1] 5\n\n27 %% 5 # This gives us the remainder after dividing 27 by 5\n\n[1] 2\n\n(27 %/% 5) + (27 %% 5)/5 # This shows how we can carry out division\n\n[1] 5.4\nAs you type expressions into R, it is important to think carefully about the order of operations. R follows the standard PEMDAS rules, but it is still easy to enter an expression in a way that produces unintended results. For this reason, you should always use parentheses whenever you are performing calculations in the numerator, denominator, or exponent to ensure the expression is evaluated as intended. Keep in mind that R ignores spaces in code, so placing numbers close together does not change the order in which operations are performed. R will always follow PEMDAS unless parentheses explicitly tell it otherwise. The examples below illustrate why parentheses are so important.\n3+4 / 2\n\n[1] 5\n\n(3+4) / 2\n\n[1] 3.5\n\n2^ 6/3\n\n[1] 21.33333\n\n2^ (6/3)\n\n[1] 4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html",
    "href": "Lecture-2-Strings-and-Text-Processing.html",
    "title": "2  Text Processing and Useful R Tools",
    "section": "",
    "text": "2.1 More Complex Logical Selections\nThis lecture will continue our review of R while also introducing some new functions and commands that you may not have seen before. As we go through the examples, it is important to run the code in your own R console in order to truly understand what the code is doing. Additionally, as you type the code, you should think about what the output will be before running the command. This will help you develop the critical thinking and programming skills needed to continue improving as a programmer. Finally, if you are unsure what the code is doing, try breaking it down into smaller sections (if applicable) or creating a simpler example.\nWe previously saw how logical operators can be used for index selection to identify values that meet certain criteria. We can expand this idea by creating more complex conditions using multiple logical comparisons. In particular, we can use the ampersand \\((\\&)\\) to represent an “AND” condition, the pipe \\((|)\\) to represent an “OR” condition, and the exclamation mark (!) to represent “NOT”. The ! operator flips logical values, turning TRUE into FALSE and FALSE into TRUE.\nBelow are a few examples showing how these logical operators work. As a reminder, we can do “math” on logical vectors because FALSE is treated as 0 and TRUE is treated as 1. This allows us to count how many values meet a condition using the sum() function.\nx &lt;- 1:11\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11\n\nx &lt; 6\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\nsum(x &lt; 6)\n\n[1] 5\n\nx[x &lt; 6]\n\n[1] 1 2 3 4 5\nIn the example below, we use logical operators to create compound statements. For example, we can display all values that are less than 5 OR greater than 9, as well as all values that are greater than 3 AND less than or equal to 8.\nx &lt; 5 | x &gt; 9\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\nx[x &lt; 5 | x &gt; 9]\n\n[1]  1  2  3  4 10 11\n\nx &gt; 3 & x &lt;= 8\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nx[x &gt; 3 & x &lt;= 8]\n\n[1] 4 5 6 7 8\nThe last major logical operator is the NOT operator, which flips a logical condition. This is useful when we want to select all values that do not meet a certain requirement, such as displaying all values that are not greater than or equal to 7.\nc(!TRUE, !FALSE)\n\n[1] FALSE  TRUE\n\n!(x &gt;= 7)\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx[!(x &gt;= 7)]\n\n[1] 1 2 3 4 5 6",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-3-Factors-and-Dates.html",
    "href": "Lecture-3-Factors-and-Dates.html",
    "title": "3  Factors, Dates, and Special Values",
    "section": "",
    "text": "3.1 Special Values\nAs we go further in our journey to becoming Data Scientists, we will come across some special values which may occasionally cause a headache or two. In this lecture, we aim to give you a crash course on some of the special values you may encounter. This includes values you may see after running functions, along with working with dates and times. Finally, we will conclude this lecture by looking at factors and how we can use them to store and work with categorical data more efficiently.\nAs we work in R, we may occasionally come across a few different special values. These include missing values (NA), values which are Not a Number (NaN), and infinite values (\\(\\pm\\) Inf). It is important to understand why each value occurs, because these are often the source of confusing results in our code. The first special value we will look at is NA. This represents a missing value, and it can be identified using the is.na() function. It should be noted that is.na() will also identify NaN values. Likewise, if we try to do math on a vector which contains a missing value, then the output will also become missing. We can correct for this by using the argument na.rm=TRUE to specify that we want NA values removed before running the calculations.\nx &lt;- c(1,2,3,NA)\nx\n\n[1]  1  2  3 NA\n\nis.na(x)\n\n[1] FALSE FALSE FALSE  TRUE\n\nsum(is.na(x))\n\n[1] 1\n\nmean(x)\n\n[1] NA\n\nmean(x, na.rm=TRUE)\n\n[1] 2\nThe next special values that we might encounter are NaN and Inf. These values are produced whenever the math is either not possible (such as taking the square root of a negative number), or when the result is too large to store in the computer. If we divide by 0, we may get NaN or Inf due to IEEE standards, even though mathematically we know the expression is undefined. So, do not worry about harming the USS Yorktown if you accidentally divide by zero. We can use the is.nan() and is.infinite() functions to identify these values.\n0/0\n\n[1] NaN\n\n(-1)^0.5\n\n[1] NaN\n\n2^478385\n\n[1] Inf\n\n5/0\n\n[1] Inf\n\n-5/0\n\n[1] -Inf\nWe can now put all of our skills together and look at an example containing all of the special values we have discussed so far. To begin, we use the sample() function to procure a random sample of values. You will get a different sample than me if you do not set the seed to the same value. Notice how we can incorporate the which() function to determine the indices of the elements that meet each condition. Also, notice that the is.na() function flags both NA and NaN values, while the is.nan() function only identifies NaN values.\nset.seed(8675309)\ny &lt;- sample(c(5, NA, NaN, -Inf, Inf), 13, replace=TRUE)\ny\n\n [1] -Inf  NaN   NA  NaN  Inf  NaN    5  Inf  NaN    5 -Inf  Inf   NA\n\ntable(y, useNA = \"ifany\")\n\ny\n-Inf    5  Inf  NaN &lt;NA&gt; \n   2    2    3    4    2 \n\nsum(is.na(y))\n\n[1] 6\n\nwhich(is.na(y))\n\n[1]  2  3  4  6  9 13\n\nsum(is.nan(y))\n\n[1] 4\n\nwhich(is.nan(y))\n\n[1] 2 4 6 9\n\nsum(is.infinite(y))\n\n[1] 5\n\nwhich(is.infinite(y))\n\n[1]  1  5  8 11 12",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Factors, Dates, and Special Values</span>"
    ]
  },
  {
    "objectID": "Lecture-4-Data-Structures-in-R.html",
    "href": "Lecture-4-Data-Structures-in-R.html",
    "title": "4  Data Structures in R",
    "section": "",
    "text": "4.1 Matrices\nOne of the most prevalent data types that we will encounter in R are dataframes. We can think of these as a combination of vectors arranged so that the first elements of one vector is associated with the first element of all of the other vectors, with the same being said for the second, third, etc. elements. Additionally, most of the data that we work with will be structured as a dataframe, so it is important for us to review these before jumping into more advanced data manipulation techniques. Additionally, some of the data we may encounter will be as a list, which essentially is a collection of data grouped together that is not necessarily of the same data type, but more will be discussed on this topic later in this write-up.\nBefore diving into dataframes, I wanted to give a quick run-down of matrices, as they occasionally make appearances in R (especially when doing mathematical simulations!). To create a matrix, we will first pass a vector in the matrix() function and specify the number of rows or columns using the nrow or ncol argument. It will fill in the matrix down each column (unless specified) until all of the elements in the vector are used. If additional elements are needed to complete the rectangular matrix then the values will be recycled from the beginning of the vector. It should be noted that all of the elements in a matrix must be of the same type, and the values are not necessarily related to each other across rows or columns as they would be for a dataframe. Examples of how the matrix will work can be seen below:\nx &lt;- 1:12\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\nmatrix(x, nrow=3)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nmatrix(x, nrow=3, byrow=TRUE)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\nWe saw previously that vectors were an example of one-dimensional data. When we deal with matrix we are dealing with two-dimensional data, since we have rows and columns. It is important to know that R indexes two-dimensional data “Row, Column”. So, if we want to look at just the first row then we can use the index selection brackets and type \"x[1,]\" while the fourth column could be found with \"x[,4]\". Examples of this can be seen below:\nx_mat &lt;- matrix(x, nrow=3, byrow=TRUE)\n\nx_mat[,1]\n\n[1] 1 5 9\n\nx_mat[1,]\n\n[1] 1 2 3 4\n\nx_mat[2,2]\n\n[1] 6",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures in R</span>"
    ]
  },
  {
    "objectID": "Lecture-5-Control-Flow-and-Functions.html",
    "href": "Lecture-5-Control-Flow-and-Functions.html",
    "title": "5  Control Flow and Functions",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Flow and Functions</span>"
    ]
  },
  {
    "objectID": "Lecture-6-Data-Visualization-with-ggplot.html",
    "href": "Lecture-6-Data-Visualization-with-ggplot.html",
    "title": "6  Data Visualization with ggplot",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Visualization with ggplot</span>"
    ]
  },
  {
    "objectID": "Lecture-7-Data-Wrangling-with-dplyr.html",
    "href": "Lecture-7-Data-Wrangling-with-dplyr.html",
    "title": "7  Data Wrangling with dplyr",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Wrangling with dplyr</span>"
    ]
  },
  {
    "objectID": "Lecture-8-Grouped-and-Bivariate-Analysis.html",
    "href": "Lecture-8-Grouped-and-Bivariate-Analysis.html",
    "title": "8  Grouped and Bivariate Analysis",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grouped and Bivariate Analysis</span>"
    ]
  },
  {
    "objectID": "Lecture-9-Handling-Missing-Data.html",
    "href": "Lecture-9-Handling-Missing-Data.html",
    "title": "9  Handling Missing Data",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Handling Missing Data</span>"
    ]
  },
  {
    "objectID": "Lecture-10-Tidy-Data-Principles.html",
    "href": "Lecture-10-Tidy-Data-Principles.html",
    "title": "10  Tidy Data Principles",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Tidy Data Principles</span>"
    ]
  },
  {
    "objectID": "Lecture-11-Distributions-Across-Groups.html",
    "href": "Lecture-11-Distributions-Across-Groups.html",
    "title": "11  Distributions Across Groups",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Distributions Across Groups</span>"
    ]
  },
  {
    "objectID": "Lecture-12-Sampling-and-CLT.html",
    "href": "Lecture-12-Sampling-and-CLT.html",
    "title": "12  Sampling and CLT",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Sampling and CLT</span>"
    ]
  },
  {
    "objectID": "Lecture-13-Confidence-Intervals-and-Comparisons.html",
    "href": "Lecture-13-Confidence-Intervals-and-Comparisons.html",
    "title": "13  Confidence Intervals and Comparisons",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Confidence Intervals and Comparisons</span>"
    ]
  },
  {
    "objectID": "Lecture-14-Hypothesis-Testing-Foundations.html",
    "href": "Lecture-14-Hypothesis-Testing-Foundations.html",
    "title": "14  Hypothesis Testing Foundations",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Hypothesis Testing Foundations</span>"
    ]
  },
  {
    "objectID": "Lecture-15-Comparing-Means-and-Groups.html",
    "href": "Lecture-15-Comparing-Means-and-Groups.html",
    "title": "15  Comparing Means and Groups",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Comparing Means and Groups</span>"
    ]
  },
  {
    "objectID": "Lecture-16-Categorical-Data-Inference.html",
    "href": "Lecture-16-Categorical-Data-Inference.html",
    "title": "16  Categorical Data Inference",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Categorical Data Inference</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#vectors",
    "href": "Lecture-1-R-Fundamentals-Review.html#vectors",
    "title": "1  R Fundamentals Review",
    "section": "1.2 Vectors",
    "text": "1.2 Vectors\nIt is important to remember that everything in R is vectorized. This includes single elements along with what we would traditionally call a vector (a combination of elements into a single group). To make a vector, we can use the c() function. To save a vector to a variable for later use, you will need to use the assignment operator (\\(&lt;\\)–), which assigns the value on the right to the variable name on the left (the value is pointing to the name).\n\nis.vector(3)\n\n[1] TRUE\n\ntest_vector &lt;- c(7, 2, 6, 9, 3, 6.43, -3, 3/2)\ntest_vector\n\n[1]  7.00  2.00  6.00  9.00  3.00  6.43 -3.00  1.50\n\nis.vector(test_vector)\n\n[1] TRUE\n\n\nWhen doing math on vectors, R performs the operation element by element (meaning the math is done on the first element of each vector, then the second element of each vector, and so on). If the vectors are of different lengths, R recycles the shorter vector until the operation has been performed on all elements of the longer vector. If the vector lengths are not multiples of each other, the operation will still be performed until the longer vector is fully “used”, but R will issue a warning message letting you know about the issue.\n\na &lt;- c(0,5,10)\nb &lt;- c(3,7,-2)\na * 2\n\n[1]  0 10 20\n\na+b # Does 3+0, 5+7, 10+(-2)\n\n[1]  3 12  8\n\na &lt;- c(0, 5, 10)\nb &lt;- c(20, 30)\na+b # Does 0+20, 5+30, 10+20\n\nWarning in a + b: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 20 35 30\n\n\nWe can also create vectors containing character elements (as long as they are in quotes) as well as vectors containing logical elements. For the logical elements, we can either type it in all capital letters or abbreviate it using the first letter.\n\nchar_vector &lt;- c(\"This is\", \"also\", \"a\", \"vector\", \"of characters\")\nchar_vector\n\n[1] \"This is\"       \"also\"          \"a\"             \"vector\"       \n[5] \"of characters\"\n\nc(T, T, FALSE, TRUE, F)\n\n[1]  TRUE  TRUE FALSE  TRUE FALSE\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit tracks his number of steps each day for one week, which were: 4,552, 7,324, 9,642, 5,304, 2,049, 6,424, and 13,284. Teach Emmit how to save these step counts as a vector in R. If he believes he can increase his steps by 15%, how can he determine the number of steps he would need to take each day?\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#data-types",
    "href": "Lecture-1-R-Fundamentals-Review.html#data-types",
    "title": "1  R Fundamentals Review",
    "section": "1.3 Data Types",
    "text": "1.3 Data Types\nAnother important idea to remember is that all objects in R have a data type. We will mainly encounter doubles (numbers), logicals (TRUE/FALSE), and characters (anything in quotes). We can determine the type of data we are working with by using the typeof() function. This will be important for us when we start trying to analyze/troubleshoot our code, as we cannot perform mathematical operations on a character vector, even if all of the characters themselves are numbers.\n\ntypeof(4.25) # Shows 4.25 is a double\n\n[1] \"double\"\n\ntypeof(FALSE) # Shows FALSE is a logical\n\n[1] \"logical\"\n\ntypeof(\"4.25\") # Shows \"4.25\" is a character because it is in quotes\n\n[1] \"character\"\n\n\nAnother reason it is important to think about data types is because a vector will automatically be coerced to the “lowest” common type present (character \\(&lt;\\) double \\(&lt;\\) logical). That is to say, if a vector has a single character element all of the values will be turned into characters. Likewise, if a vector consists of doubles and logicals then the vector will be presented as doubles. We can explicitly coerce a vector to a specific type using functions such as as.numeric() or as.character(). This process can be seen below.\n\nc(1, 2, 3, 4, 5)\n\n[1] 1 2 3 4 5\n\ntypeof(c(1, 2, 3, 4, 5))\n\n[1] \"double\"\n\nx &lt;- c(1, 2, 3, 4, \"5\")\nx\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\ntypeof(x)\n\n[1] \"character\"\n\nis.numeric(x)\n\n[1] FALSE\n\nis.character(x)\n\n[1] TRUE\n\nas.numeric(x) # Converting the character vector to be numeric\n\n[1] 1 2 3 4 5\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen coercing a vector to numeric using as.numeric(), any values that cannot be converted will become NA\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit’s fitness tracker recorded several pieces of information for a single day. His step count was 6,424 steps, the tracker recorded that he worked out that day (TRUE), and he added the note “Leg day” to describe his workout. Teach Emmit how to check the data type of each of these values in R. Then, combine the step count and the note into a single vector and determine the data type of the resulting vector. Explain to him why this data type occurs.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#built-in-functions-in-r",
    "href": "Lecture-1-R-Fundamentals-Review.html#built-in-functions-in-r",
    "title": "1  R Fundamentals Review",
    "section": "1.4 Built-in Functions in R",
    "text": "1.4 Built-in Functions in R\nThere are several built-in functions in base R that are useful for working with numeric data. These include mean(), median(), sd(), min(), max(), sqrt(), length(), and many more. All of these functions require an input, which is typically provided as a vector. If we forget to pass the values as a vector, the function may still run, but not in the way you would expect. In the example below, mean(4, 36, 25, 9, 16) returns 4 because mean() treats the first value as the data and interprets the remaining values as additional arguments, which are ignored.\n\ny &lt;- c(4,36, 25, 9, 16)\nmean(y)\n\n[1] 18\n\nmean(4,36, 25, 9, 16)\n\n[1] 4\n\n\nAs you look at the following functions, note that different functions return different types of output. Some functions return a single value:\n\nsum(y)\n\n[1] 90\n\nlength(y)\n\n[1] 5\n\nmedian(y)\n\n[1] 16\n\nsd(y)\n\n[1] 12.78671\n\n\nWe can also combine functions to compute new values, such as the mean:\n\nsum(y)/length(y)\n\n[1] 18\n\n\nOther functions return a vector with the same number of elements as the input:\n\nsort(y)\n\n[1]  4  9 16 25 36\n\nsqrt(y)\n\n[1] 2 6 5 3 4\n\n\nFinally, some functions return multiple values:\n\nmin(y)\n\n[1] 4\n\nmax(y)\n\n[1] 36\n\nrange(y)\n\n[1]  4 36\n\n\nFinally, we can apply function to the results of functions as well:\n\ndiff(range(y))\n\n[1] 32\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf a vector contains missing values (NA), many built-in functions will return NA by default. You can remove missing values from the calculation by including na.rm = TRUE inside the function.\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit recorded his daily step counts for one week as the values 4,552, 7,324, 9,642, 5,304, 2,049, 6,424, and 13,284. Using built-in R functions, teach Emmit how to calculate the total number of steps he took during the week, his average number of steps per day, his minimum and maximum daily step counts, and a measure of how spread out his step counts are.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#logical-operators-and-index-selection",
    "href": "Lecture-1-R-Fundamentals-Review.html#logical-operators-and-index-selection",
    "title": "1  R Fundamentals Review",
    "section": "1.5 Logical Operators and Index Selection",
    "text": "1.5 Logical Operators and Index Selection\nBesides just carrying out mathematical operations, it is also useful to use logical operators to select only certain values or determine how many values meet certain criteria. These logical operators include less than \\((&lt;)\\), greater than \\((&gt;)\\), equal to \\((==)\\), and not equal to \\((!=)\\). We can also use less than or equal to \\((&lt;=)\\) and greater than or equal to \\((&gt;=)\\).\nSometimes it is helpful to display only the values that meet certain criteria, which can be done using index selection. To do this, we call the vector and then use index selection brackets to specify which elements we want to display. Logical operators are especially useful here because their output is a logical vector, which can be passed directly into the index selection brackets.\n\nx &lt;- c(2, 5, 7, 3, 1, 5, 8, 3)\nx\n\n[1] 2 5 7 3 1 5 8 3\n\n\n\nx == 3\n\n[1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n\nsum(x == 3) # Cunts the number of TRUEs\n\n[1] 2\n\nx[x == 3]\n\n[1] 3 3\n\nlength(x[x == 3]) # Counts the number of values meeting the criteria\n\n[1] 2\n\nx &lt; 5\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\nx[x &lt; 5] # Displaying only the values that are less than 5\n\n[1] 2 3 1 3\n\n\nUsing a negative sign indicates that we want all elements except the specified indices.\n\nx[c(1,4,6)]\n\n[1] 2 3 5\n\nx[-c(1,4,6)]\n\n[1] 5 7 1 8 3\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nUsing Emmit’s weekly step counts of 4,552, 7,324, 9,642, 5,304, 2,049, 6,424, and 13,284, Emmit decides that a day counts as a “good workout day” if he takes more than 7,000 steps. Teach Emmit how to use logical operators and index selection in R to identify which days meet this criterion, count how many good workout days he had during the week, and display only the step counts from those days.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#r-markdown",
    "href": "Lecture-1-R-Fundamentals-Review.html#r-markdown",
    "title": "1  R Fundamentals Review",
    "section": "1.6 R Markdown",
    "text": "1.6 R Markdown\nAs we progress as data scientists, it is important to organize our code in a cohesive way that supports reproducibility. One of the best ways to do this is by writing our work in an R Markdown document. R Markdown allows us to keep our code, output, and written explanations all in one place. When we are finished, we can “knit” the document into a final report that displays both the code we wrote and the output directly beneath it. This approach makes it easy to update results by changing the code, without needing to copy and paste output manually.\nTo create an R Markdown document, open RStudio and select File -\\(&gt;\\) New File -\\(&gt;\\) R Markdown. You will be prompted to enter a document title and choose an output format. For this class, you should knit your documents as PDFs, so you will select that option. The first time you knit a PDF, RStudio may ask you to install a TeX distribution; this can be done directly through R and only needs to be installed once. To do so, you may need to install TinyTeX by running install.packages(\"tinytex\"), loading it with library(tinytex), and then installing the TeX distribution using tinytex::install_tinytex(), after which you should be able to knit the file as a PDF.\nAt the top of the document, you will see a header (the content between the — lines). This header contains information such as the title, author, date, and output format. You generally do not need to edit the output format manually, as knitting the document will automatically update it depending on whether you knit to PDF, HTML, or Word. Near the top of the file, you will also see an R setup chunk. This chunk should remain at the top of the document and is commonly used for code that should run but not appear in the final output, such as loading libraries or importing data. This behavior occurs because the chunk includes the argument include = FALSE.\nEverything below the setup chunk can be deleted before you begin working, as the default content is not needed for this course. When you are ready to write code, you will create an R chunk. This can be done manually or by clicking the green C button near the top of the editor and selecting R. All code should be written inside these chunks (not the output). While working, you can run the code in a chunk by clicking the green play button in the top-right corner of the chunk. If this button is missing, make sure the chunk’s triple backticks have not been accidentally deleted.\nAny written explanations or comments describing what you are doing should be placed outside of code chunks in the white space of the document. This is where you should describe the problem and explain your results. Avoid placing long comments inside R chunks, as they can make the code difficult to read. You can also organize your document using headers by starting a line with the pound sign (#). Using multiple pound signs creates subheaders. Be sure to leave a blank line before and after each header.\nOnce you are satisfied with your document, you can knit it to a PDF by clicking the “Knit” button near the top of the editor. If an error is present, the document will not knit successfully, and RStudio will indicate which chunk caused the issue and why. These errors are usually straightforward to fix—just be sure to carefully read the error message.\n\n\nLecture Video\n\n\n\nIn-Class Exercises\n\n\nIn-Class Exercises Video Solutions\n\n\n\nProblem Set Questions",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#using-r-as-a-computer",
    "href": "Lecture-1-R-Fundamentals-Review.html#using-r-as-a-computer",
    "title": "1  R Fundamentals Review",
    "section": "",
    "text": "Try it Out\n\n\n\nEmmit is planning his weekly expenses and wants to calculate how much money he has left after buying groceries, gas, and coffee. He typically has $100 to spend each week. So far, he has paid $30 for gas, split a $72 grocery bill with two other friends, and bought a $4 coffee three times. Teach Emmit how he can determine how much money he has left for the week using R.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#identifying-patterns-using-grep-and-grepl",
    "href": "Lecture-2-Strings-and-Text-Processing.html#identifying-patterns-using-grep-and-grepl",
    "title": "2  Text Processing and Useful R Tools",
    "section": "2.2 Identifying patterns using grep() and grepl()",
    "text": "2.2 Identifying patterns using grep() and grepl()\nAnother powerful way to identify values meeting certain criteria is to use the grep() or grepl() function. These functions allow us to identify patterns within character vectors. Both functions work in the same way, but they return different types of output: grep() returns the indices that match the pattern, while grepl() returns a logical vector indicating which values match. The function works by passing in a pattern that we wish to search for along with the vector that we are searching through, such as grep(\"pattern\", x).\nIt should be noted that patterns are case sensitive, meaning \"H\" will only identify elements containing a capital H, not a lowercase h. If we wish to search at the beginning of a string, we can use the caret \\(\\wedge\\). For example, the pattern $^Happy will identify all elements that start with \"Happy\" and will not match it if it appears later in the string.\n\ngreetings &lt;- c(\"Happy Birthday\", \"Merry Christmas\", \"Trick or Treat\", \n              \"Happy Holidays\",\"That makes me Happy\")\ngreetings\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\ngrep(\"Happy\", greetings)\n\n[1] 1 4 5\n\ngreetings[grep(\"Happy\", greetings)]\n\n[1] \"Happy Birthday\"      \"Happy Holidays\"      \"That makes me Happy\"\n\ngrepl(\"Happy\", greetings)\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE\n\ngreetings[grepl(\"Happy\", greetings)]\n\n[1] \"Happy Birthday\"      \"Happy Holidays\"      \"That makes me Happy\"\n\ngrep(\"^Happy\", greetings)\n\n[1] 1 4\n\ngreetings[grep(\"^Happy\", greetings)]\n\n[1] \"Happy Birthday\" \"Happy Holidays\"\n\n\nWe can also identify elements that end with a certain pattern using the dollar sign ($). For example, the pattern s$ will identify all elements that end with the letter \"s\". Additionally, we can use brackets to indicate that we want to match any one of the characters inside the brackets. For instance, the pattern [ioa]n will match \"in\", \"on\", or \"an\" anywhere in the string. If we want to match any character, we can use a period (.). For example, the pattern t. will match the letter \"t\" followed by any single character.\n\ngreetings\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\ngrep(\"s$\", greetings)\n\n[1] 2 4\n\ngreetings[grep(\"s$\", greetings)]\n\n[1] \"Merry Christmas\" \"Happy Holidays\" \n\ngrep(\"[sa]t\", greetings)\n\n[1] 2 3 5\n\ngreetings[grep(\"[sa]t\", greetings)]\n\n[1] \"Merry Christmas\"     \"Trick or Treat\"      \"That makes me Happy\"\n\ngrep(\"t.\", greetings)\n\n[1] 1 2 5\n\ngreetings[grep(\"t.\", greetings)]\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"That makes me Happy\"\n\n\nWhile these patterns may seem confusing or even a little intimidating at first, they are very powerful tools that we should become familiar with. A good way to practice is to create small examples and give yourself a simple goal. Since the example is small, it will be easy to check whether the output matches what you expected. Practicing like this will help you understand the function while also reinforcing an important troubleshooting skill: simplifying the problem.\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit wrote workout notes in the character vector below. Teach Emmit how to use grep() to find the indices of the notes that contain the pattern \"Run\", and then display only those matching notes. Also, teach Emmit how to use grepl() to produce a logical vector for the same pattern and to display the values. Finally, have Emmit identify which notes start with \"Rest\".\n\nnotes &lt;- c(\"Run 2 miles\", \"Rest day\", \"Leg day\", \"Walk 30 min then Rest\", \"Run intervals\", \n           \"Upper body\", \"Rest and stretch\", \"Bike 10 miles\", \"run 1 mile\", \"Run fast\")\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#substituting-patterns-using-sub-and-gsub",
    "href": "Lecture-2-Strings-and-Text-Processing.html#substituting-patterns-using-sub-and-gsub",
    "title": "2  Text Processing and Useful R Tools",
    "section": "2.3 Substituting patterns using sub() and gsub()",
    "text": "2.3 Substituting patterns using sub() and gsub()\nTwo functions related to grep() is sub() and gsub(). These functions search for a pattern (like grep()) and then replace it with another specified pattern. This is especially helpful when cleaning data and preparing it to be analyzed. To use these functions, we provide three inputs: the pattern we want to identify, the replacement pattern, and the vector we want to modify. Both sub() and gsub() work the same way, but sub() only replaces the first occurrence of the pattern in each element, while gsub() replaces every occurrence.\nWe can also use some of the same pattern commands we learned with grep(), such as using ^ to represent the beginning of a string and $ to represent the end of a string. The function works as follows: sub(\"pattern to identify\", \"replacement pattern\", x). Note that sub() and gsub() do not permanently change the original vector unless you save the result to a variable.\n\ngreetings &lt;- c(\"Happy Birthday\", \"Merry Christmas\", \"Trick or Treat\", \n               \"Happy Holidays\",\"That makes me Happy\")\ngreetings\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\n\nIn the code below, we identify the \"H\" pattern and replace it with a lowercase version. You can see that sub() will only make the replacement on the first occurrence within each element while gsub() will carry out the replacement for every occurrence within each element.\n\nsub(\"H\", \"h\", greetings)\n\n[1] \"happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"happy Holidays\"      \"That makes me happy\"\n\ngsub(\"H\", \"h\", greetings)\n\n[1] \"happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"happy holidays\"      \"That makes me happy\"\n\n\nThis might be beneficial if we need to replace a word or substring. The code below shows how we replace the pattern \"Birthday\" with \"New Year!\".\n\nsub(\"Birthday\", \"New Year!\", greetings)\n\n[1] \"Happy New Year!\"     \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\n\nWe can get creative with the way we identify patterns and make alterations. In one of the lines of code below, we identify the end of the pattern and replace the ending with an exclamation mark. In another line we identify the beginning of the pattern and replace it with the phrase \"Hi, \". Finally, on the last line we identify any spaces and replace them with nothing (essentially removing the spaces).\n\nsub(\"$\", \"!\", greetings)\n\n[1] \"Happy Birthday!\"      \"Merry Christmas!\"     \"Trick or Treat!\"     \n[4] \"Happy Holidays!\"      \"That makes me Happy!\"\n\nsub(\"^\", \"Hi, \", greetings)\n\n[1] \"Hi, Happy Birthday\"      \"Hi, Merry Christmas\"    \n[3] \"Hi, Trick or Treat\"      \"Hi, Happy Holidays\"     \n[5] \"Hi, That makes me Happy\"\n\ngsub(\" \", \"\", greetings)\n\n[1] \"HappyBirthday\"    \"MerryChristmas\"   \"TrickorTreat\"     \"HappyHolidays\"   \n[5] \"ThatmakesmeHappy\"\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit’s workout notes are inconsistent, so he stored them in the vector below. Teach Emmit how to use sub() to replace the first occurrence of \"Workout\" with \"Session\" in each element of the vector. Then teach Emmit how to use gsub() to replace every occurrence of \"min\" with \"minutes\".\n\nmessy &lt;- c(\"Workout: Run 2 miles\", \"Workout: Run 10 min Walk 30 min\", \n           \"Workout: Leg day\", \"Workout: Rest day\", \"Workout: Run 25 min\")\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#special-functions-in-r",
    "href": "Lecture-2-Strings-and-Text-Processing.html#special-functions-in-r",
    "title": "2  Text Processing and Useful R Tools",
    "section": "2.4 Special Functions in R",
    "text": "2.4 Special Functions in R\nThere are a few additional special functions that we will continue to use throughout this course. The first one we should discuss is the sample() function. This function takes an input vector and randomly samples values from it. If more values are requested than are in the original vector, then an error message will appear (for example, we cannot select 15 items if there are only 10 available). In order to sample more values than the vector contains, we need to sample with replacement by using replace = TRUE. If we want to get the same results every time we run sample(), we need to set the random seed using the set.seed() function. This ensures that the pseudo-random number generator produces the same sequence of results each time.\nIn the code below, we can see that running sample() multiple times produces different results.\n\nabc &lt;- letters[1:10]\nabc\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"\n\nsample(abc, 5)\n\n[1] \"g\" \"i\" \"j\" \"c\" \"a\"\n\nsample(abc, 5)\n\n[1] \"i\" \"b\" \"d\" \"c\" \"f\"\n\n\nIf we try to sample more values than are present, we get an error. To fix this, we specify replace = TRUE to allow sampling to be done with replacement (which allows duplicate values).\n\nsample(abc, 15)\n\nError in sample.int(length(x), size, replace, prob) : cannot take a sample larger than the population when 'replace = FALSE'\n\nsample(abc, 15, replace=TRUE)\n\n [1] \"e\" \"g\" \"a\" \"h\" \"h\" \"c\" \"e\" \"f\" \"c\" \"j\" \"a\" \"g\" \"j\" \"a\" \"i\"\n\n\nIf we want reproducible values, then we need to set the seed. If you want to think about it like a book filled with random numbers, setting the seed makes sure you start reading the numbers off the same page. We can see an example of this below.\n\nset.seed(123)\nsample(abc, 5)\n\n[1] \"c\" \"j\" \"b\" \"h\" \"f\"\n\nset.seed(123)\nsample(abc, 5)\n\n[1] \"c\" \"j\" \"b\" \"h\" \"f\"\n\nsample(abc, 5)\n\n[1] \"e\" \"d\" \"f\" \"h\" \"a\"\n\n\nAnother function that is important for us to have experience with is the which() function. This function (much like grep()) tells us which indices meet a logical condition. This can be helpful when we want the output to be indices instead of a vector of TRUE and FALSE values. Examples of using the which() function can be seen below, including one example that identifies which values are even by checking which elements have a remainder of 0 when divided by 2.\n\nnum &lt;- sample(1:15, size=10, replace=TRUE)\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\nwhich(num &gt; 10)\n\n[1]  2  5  7 10\n\nnum[which(num &gt; 10)]\n\n[1] 11 11 12 13\n\nwhich(num %% 2 == 0)\n\n[1] 1 7\n\nnum[which(num %% 2 == 0)]\n\n[1] 10 12\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit wants to randomly choose 7 workouts from the vector below to build a weekly plan. Teach Emmit how to use sample() to select 7 workouts so he gets the same random results each time he runs the code. After that, Emmit tracks his workout minutes for the week using the vector below and wants to know which days were longer than 60 minutes. Teach Emmit how this can be done in R.\n\nworkouts &lt;- c(\"Run\", \"Walk\", \"Bike\", \"Swim\")\ndaily_mins &lt;- c(25, 70, 45, 10, 65, 80, 35)\n\n\n\nClick to see the solution\n\n\n\n\n\nThe match() function may also be of some use to us throughout the semester. It returns the index position of each value in the first vector within the second vector (and returns NA if a value is not found). Looking at the example below, this process should make a little more sense. For example, the output tells us where each value from 1:15 appears in the vector num.\n\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\n1:15\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n\nmatch(1:15, num)\n\n [1] NA NA  4 NA  3 NA NA NA  6  1  2  7 10 NA NA\n\n\nThe duplicated() function helps us determine if we have seen a value before, while the unique() function returns all values without any duplicated elements.\n\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\nduplicated(num)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\nnum[!duplicated(num)]\n\n[1] 10 11  5  3  9 12 13\n\nunique(num)\n\n[1] 10 11  5  3  9 12 13\n\n\nThe any() and all() functions check whether a logical condition has been met and then output a single logical value. The any() function checks if at least one element meets the criteria, while the all() function checks if every element meets the criteria.\n\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\nany(num &gt; 10)\n\n[1] TRUE\n\nany(num &gt;= 15)\n\n[1] FALSE\n\nall(num &lt; 10)\n\n[1] FALSE\n\nall(num &lt;= 15)\n\n[1] TRUE\n\n\nThe last thing we will discuss in this lecture is the %in% operator. This operator is useful when we want to check whether values in a vector match any value from a list of possible options. The example below shows why it is beneficial. If we use == c(1, 2), R performs an element-by-element comparison and recycles the shorter vector, which produces incorrect results. Using %in% fixes this by checking whether each element is in the set {1, 2}. This is especially helpful when we want to test for membership in multiple possible values without writing long logical expressions.\n\nx &lt;- c(1, 1, 1, 1, 2, 2, 2, 3, 3, 4)\nx\n\n [1] 1 1 1 1 2 2 2 3 3 4\n\nx[ x == c(1,2)]\n\n[1] 1 1 2\n\nx == c(1,2)\n\n [1]  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\nx %in% c(1,2)\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nx[ x %in% c(1,2)]\n\n[1] 1 1 1 1 2 2 2\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit copied his workout log into the vector below and wants to check for repeats. Teach Emmit how to identify any duplicated values. Then using the log vector, show Emmit how he could identify any entries showing \"Walk\" or \"Bike\". Finally, using the vector below describing the lengths of his workout, teach Emmit how to determine if any workouts were longer than 45 minutes and if all the workouts were less than 1 hour.\n\nlog &lt;- c(\"Run\", \"Walk\", \"Walk\", \"Bike\", \"Yoga\", \"Run\", \"Rest\", \"Swim\", \"Swim\", \"Bike\")\ngoal_mins &lt;- c(30, 25, 25, 45, 20, 35, 0, 50, 40)\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\nLecture Video\n\n\n\nIn-Class Exercises\n\n\nIn-Class Exercises Video Solutions\n\n\n\nProblem Set Questions",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#more-complex-logical-selections",
    "href": "Lecture-2-Strings-and-Text-Processing.html#more-complex-logical-selections",
    "title": "2  Text Processing and Useful R Tools",
    "section": "",
    "text": "Try it Out\n\n\n\nEmmit tracked how many minutes he exercised each day for 11 days using the vector below. He considers a day “good” if his workout was more than 35 minutes AND less than or equal to 80 minutes. Teach Emmit how he can display the values meeting that criteria. He also wants to display the days where he exercised less than 20 minutes OR more than 90 minutes. Finally, he wants to display all days that are NOT greater than or equal to 60 minutes.\n\nmins &lt;- c(12, 40, 75, 95, 18, 62, 35, 81, 0, 90, 55)\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-3-Factors-and-Dates.html#datestimes",
    "href": "Lecture-3-Factors-and-Dates.html#datestimes",
    "title": "3  Factors, Dates, and Special Values",
    "section": "3.2 Dates/Times",
    "text": "3.2 Dates/Times\nDealing with dates and times in R can sometimes be a tricky task because there are multiple different representations they can take. For instance, some formats store dates as the number of days since January 1st, 1970, while others store date/time as the number of seconds since January 1st, 1970. Still others store the date/time as a list describing the seconds, minutes, hours, month, year, etc. Therefore, this section aims to give you insight into how we can manage dates and times in R.\nLet’s first take a look at the following example. Here, I have a date saved as a character string. I can then use the strptime() function (which stands for string parsed time) to convert the string into a time object. The function works by passing the string into the function and then specifying the format that the string follows. For example, you must specify that the month comes first, then the day, and then the year. To do this, you need to use formatting abbreviations (which can be found in the table directly beneath this code), and the format must match the string exactly. If it does not match, an NA value will be returned.\n\ntuesday_class &lt;- \"January 27th, 2026\"\nstrptime(tuesday_class, \"%B %dth, %Y\", tz = \"EST\")\n\n[1] \"2026-01-27 EST\"\n\ntuesday_class &lt;- \"Jan. 27, 26\"\nstrptime(tuesday_class, \"%B %dth, %Y\", tz = \"EST\") # Does not match \n\n[1] NA\n\nstrptime(tuesday_class, \"%b. %d, %y\", tz = \"EST\") \n\n[1] \"2026-01-27 EST\"\n\n\n\n\n\nSymbol\nMeaning\nExample\n\n\n\n\n%d\nday as a number\n1-31\n\n\n%a\nabbreviated weekday\nMon\n\n\n%A\nunabbreviated weekday\nMonday\n\n\n%m\nmonth as a number\n1-12\n\n\n%b\nabbreviated month\nJan\n\n\n%B\nunabbreviated month\nJanuary\n\n\n%y\n2-digit year\n26\n\n\n%Y\n4-digit year\n2026\n\n\n%S\nseconds as a number\n0-59\n\n\n%M\nminutes as a number\n0-59\n\n\n%I\nhours from 12-hour clock\n1-12\n\n\n%H\nhours from 24-hour clock\n0-23\n\n\n%p\nam/pm indicator\nAM/PM\n\n\n\nThe first date/time type that we will discuss is the Date type. This type does not include any time component, and instead only stores the calendar date. It stores the date as the number of days since January 1st, 1970. This type is helpful when the difference between dates should be measured in days, since it does not include increments smaller than a day. To create a Date object, we can use the as.Date() function as shown below. Using the unclass() function, we can see how the data is stored. For example, January 27th, 2026 is stored as 20480 days since January 1st, 1970.\n\ntuesday_class &lt;- \"January 27th, 2026\"\ntuesday_class_date &lt;- as.Date(tuesday_class, \"%B %dth, %Y\")\nunclass(tuesday_class_date)\n\n[1] 20480\n\n\nNotice how no aspect of the time is stored using this method.\n\nsuperbowl &lt;- \"February 8th, 2026 at 6:30 PM\"\nstrptime(superbowl, \"%B %dth, %Y at %I:%M %p\", tz = \"EST\")\n\n[1] \"2026-02-08 18:30:00 EST\"\n\nsb_date &lt;- as.Date(superbowl, \"%B %dth, %Y at %I:%M %p\", tz = \"EST\")\nsb_date\n\n[1] \"2026-02-08\"\n\nclass(sb_date)\n\n[1] \"Date\"\n\nunclass(sb_date)\n\n[1] 20492\n\n\nAnother way we may wish to store the date/time is as the number of seconds since January 1st, 1970. This is beneficial if we are interested in calculating precise differences between dates and times. To do this, we use the as.POSIXct() function (the \"ct\" can be thought of as calendar time or continuous time). Using the class() function, we can see that the variable is no longer stored as a Date, but instead as a POSIX time object (note: POSIX stands for the Portable Operating System Interface, which is a standard set by the IEEE). Notice how the time component is now stored, along with the specified time zone. When we use the unclass() function, we can see that the value is stored as a number of seconds rather than a number of days.\n\nsuperbowl &lt;- \"February 8th, 2026 at 6:30 PM\"\nsb_ct &lt;- as.POSIXct(superbowl, \"%B %dth, %Y at %I:%M %p\", tz = \"EST\")\nsb_ct\n\n[1] \"2026-02-08 18:30:00 EST\"\n\nclass(sb_ct)\n\n[1] \"POSIXct\" \"POSIXt\" \n\nunclass(sb_ct)\n\n[1] 1770593400\nattr(,\"tzone\")\n[1] \"EST\"\n\n\nThe final format we will discuss stores date/time as a list of components corresponding with the given date/time. To do this we will use the as.POSIXlt() function (the \"lt\" can be thought of as local time or list time). It stores the seconds, minutes, and hours (on a 24-hour clock) along with the day of the month, the month (with January being 0), the year since 1900, and additional useful information. This can all be seen below using the unclass() function. (Note: the output format may vary depending on your system.)\n\nsuperbowl &lt;- \"February 8th, 2026 at 6:30 PM\"\nsb_lt &lt;- as.POSIXlt(superbowl, \"%B %dth, %Y at %I:%M %p\", tz = \"EST\")\nsb_lt \n\n[1] \"2026-02-08 18:30:00 EST\"\n\nclass(sb_lt)\n\n[1] \"POSIXlt\" \"POSIXt\" \n\nunclass(sb_lt)\n\n$sec\n[1] 0\n\n$min\n[1] 30\n\n$hour\n[1] 18\n\n$mday\n[1] 8\n\n$mon\n[1] 1\n\n$year\n[1] 126\n\n$wday\n[1] 0\n\n$yday\n[1] 38\n\n$isdst\n[1] 0\n\n$zone\n[1] \"EST\"\n\n$gmtoff\n[1] NA\n\nattr(,\"tzone\")\n[1] \"EST\"\nattr(,\"balanced\")\n[1] TRUE\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit is scheduling study sessions for his Data Science class, but he wrote the dates in different formats in his notes. He has the following four entries: “January 27th, 2026”, “Feb. 3, 26”, “Tuesday the 10th of February 2026”, and “02-17-26”. Teach Emmit how he can convert each entry into a date object.\n\n\nClick to see the solution\n\n\n\n\n\nWhile the three formats above are important, it can be hard to remember them all in practice. A recent package that makes working with dates and times easier is the lubridate library. This library allows us to use functions like mdy_hm() if our string is in Month-Day-Year Hour-Minute form. There are similar functions for other common formats (like ymd(), ymd_hms(), dmy_h(), etc.). The output of these functions is typically a POSIXct object (which stores the number of seconds since January 1st, 1970).\n\n# if it is your first time using it you may need to install it first\n# install.packages(lubridate)\nlibrary(lubridate)\n\n\nsuperbowl &lt;- \"February 8th, 2026 at 6:30 PM\"\nsb_lubridate &lt;- mdy_hm(superbowl, tz=\"EST\")\nsb_lubridate\n\n[1] \"2026-02-08 18:30:00 EST\"\n\nclass(sb_lubridate)\n\n[1] \"POSIXct\" \"POSIXt\" \n\nunclass(sb_lubridate)\n\n[1] 1770593400\nattr(,\"tzone\")\n[1] \"EST\"\n\n\nThe lubridate library is very powerful, because it often does not require us to specify the exact structure of the string like we needed to do earlier. Below, we show four different ways of writing February 4th, 2026, and as long as we specify that they are in Day-Month-Year form, lubridate will correctly convert each one. We can even pass in strings with different formats into the parse_date_time() function as long as we list the possible formats.\nHowever, we do need to be careful, because some date formats are ambiguous. For example, one of the entries below is interpreted incorrectly because 26-02-04 could represent multiple formats depending on the convention. The last example clears this up by writing the year as 2026 instead of just 26.\n\ndates &lt;- c(\"4th of February 2026\", \"4/Feb/26\", \"04-02-2026\", \"040226\")\ndmy(dates)\n\n[1] \"2026-02-04\" \"2026-02-04\" \"2026-02-04\" \"2026-02-04\"\n\ndates &lt;- c(\"4th of February 2026\", \"26-02-04\", \"04-02-2026\")\nparse_date_time(dates, c(\"dmy\", \"ymd\"))\n\n[1] \"2026-02-04 UTC\" \"2004-02-26 UTC\" \"2026-02-04 UTC\"\n\ndates &lt;- c(\"4th of February 2026\", \"2026-02-04\", \"04-02-2026\")\nparse_date_time(dates, c(\"dmy\", \"ymd\"))\n\n[1] \"2026-02-04 UTC\" \"2026-02-04 UTC\" \"2026-02-04 UTC\"\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit decided that manually typing formatting strings is too annoying, so he wants to use lubridate instead. He has the following entries: “2/04/2026 6:15 PM”, “2026 2-11”, “18th of February 2026 5 PM”, and “Wed. 2/25/2026”. Teach Emmit how he can use the lubridate package to convert these values into date/times.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Factors, Dates, and Special Values</span>"
    ]
  },
  {
    "objectID": "Lecture-3-Factors-and-Dates.html#date-math",
    "href": "Lecture-3-Factors-and-Dates.html#date-math",
    "title": "3  Factors, Dates, and Special Values",
    "section": "3.3 Date Math",
    "text": "3.3 Date Math\nOne of the reasons it is important to talk about the different ways dates and times are stored in R is because we often find ourselves wanting to do “math” with them. For instance, maybe we are interested in seeing how many seconds it took for a function to run, how many days old we are, or the time differences between purchases or incidents at a large company. To do those things, we first need to convert values into an actual date/time type, and then we need to compute differences between those date/time values. Both are shown below.\nIf we are dealing with dates/times saved as POSIXct (the number of seconds since January 1st, 1970), then we can subtract the two variables and R will return a time difference (by default displayed in days, often with decimals). The variables need to be compatible date/time types in order to subtract them. Storing time in seconds allows us to be fairly precise in determining time differences. We will also see how to request results in units other than days a little later on.\n\nmlk_day &lt;- \"January 19th, 2026\"\nas.POSIXct(mlk_day, \"%B %dth, %Y\", tz = \"EST\")\n\n[1] \"2026-01-19 EST\"\n\nmlk_ct &lt;- as.POSIXct(mlk_day, \"%B %dth, %Y\", tz = \"EST\")\nunclass(mlk_ct)\n\n[1] 1768798800\nattr(,\"tzone\")\n[1] \"EST\"\n\nvalentines_day_dinner &lt;- \"February 14th, 2026 at 6:47 PM\"\nvalentines_ct &lt;- as.POSIXct(valentines_day_dinner, \"%B %dth, %Y at %I:%M %p\", tz = \"EST\")\nunclass(valentines_ct)\n\n[1] 1771112820\nattr(,\"tzone\")\n[1] \"EST\"\n\nvalentines_ct - mlk_ct\n\nTime difference of 26.78264 days\n\n(1771112820- 1768798800)/(60*60*24)\n\n[1] 26.78264\n\n\nWe can do something similar if our data is saved as a Date (the number of days since January 1st, 1970). This will return differences in whole days only, and it does not allow for any measurement smaller than a day.\n\nmlk_date &lt;- as.Date(mlk_day, \"%B %dth, %Y\", tz = \"EST\")\nunclass(mlk_date)\n\n[1] 20472\n\nvalentines_date &lt;- as.Date(valentines_day_dinner, \"%B %dth, %Y at %I:%M %p\", tz = \"EST\")\nunclass(valentines_date)\n\n[1] 20498\n\nvalentines_date - mlk_date\n\nTime difference of 26 days\n\n(20498 - 20472)\n\n[1] 26\n\n\nBefore discussing another method for calculating differences, it helps to know how to get “right now” and “today” in R. In lubridate, now() gives the current date/time and today() gives the current date. (These results will depend on when and where you run the code.)\n\nnow()\n\n[1] \"2026-01-27 21:09:57 EST\"\n\ntoday()\n\n[1] \"2026-01-27\"\n\n\nIf you want the time difference in a unit other than days, you can use the difftime() function. This function allows you to pass in two date/times along with the units you want the difference in. The default units are days.\n\ndifftime(valentines_ct, mlk_ct)\n\nTime difference of 26.78264 days\n\ndifftime(valentines_ct, mlk_ct, units=\"sec\")\n\nTime difference of 2314020 secs\n\ndifftime(valentines_ct, mlk_ct, units=\"mins\")\n\nTime difference of 38567 mins\n\ndifftime(valentines_ct, mlk_ct, units=\"hours\")\n\nTime difference of 642.7833 hours\n\ndifftime(valentines_ct, mlk_ct, units=\"days\")\n\nTime difference of 26.78264 days\n\ndifftime(valentines_ct, mlk_ct, units=\"weeks\")\n\nTime difference of 3.826091 weeks\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit is trying to see how long he actually spends working on homework (he says “2-3 hours”, but the data might disagree). He recorded the start time as “February 13th, 2026 at 6:47 PM” and the end time as “February 13th, 2026 at 8:05 PM”. Teach him how he can determine the time he spent using both the POSIXct format and using the difftime() function, while reporting the length of time in both hours and minutes.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Factors, Dates, and Special Values</span>"
    ]
  },
  {
    "objectID": "Lecture-3-Factors-and-Dates.html#factors",
    "href": "Lecture-3-Factors-and-Dates.html#factors",
    "title": "3  Factors, Dates, and Special Values",
    "section": "3.4 Factors",
    "text": "3.4 Factors\nIf we are dealing with categorical values, then it will often make sense to store the data as a factor. This is because categorical data usually has a relatively small number of possible values, and factors allow R to store those repeated categories efficiently “behind the scenes” by keeping a set of levels and referencing them. We do not need to be too concerned about exactly how the storage works, but we should know how to convert a vector to a factor when we have categorical data with finitely many repeated values.\nTo convert a vector to a factor, we can use the factor() function. An example is shown below. Notice how the elements are converted from a character vector to a factor. Also notice that it does not make sense to do a logical comparison like &lt; for an unordered factor, since one category is not inherently greater than another (so we get a warning message).\n\nmedals &lt;- c(\"gold\", \"silver\", \"bronze\", \"none\")\nset.seed(123)\nmedals_won &lt;- sample(medals, 20, replace=TRUE, prob=c(0.1, 0.2, 0.3, 0.4))\n\nmedals_won\n\n [1] \"none\"   \"silver\" \"bronze\" \"silver\" \"gold\"   \"none\"   \"bronze\" \"silver\"\n [9] \"bronze\" \"bronze\" \"gold\"   \"bronze\" \"bronze\" \"bronze\" \"none\"   \"silver\"\n[17] \"none\"   \"none\"   \"none\"   \"gold\"  \n\nmedals_factor &lt;- factor(medals_won)\nmedals_factor\n\n [1] none   silver bronze silver gold   none   bronze silver bronze bronze\n[11] gold   bronze bronze bronze none   silver none   none   none   gold  \nLevels: bronze gold none silver\n\n\n\nmedals_factor[1] &lt; medals_factor[2]\n\nWarning in Ops.factor(medals_factor[1], medals_factor[2]): '&lt;' not meaningful\nfor factors\n\n\n[1] NA\n\n\nIn the example above we created a nominal (unordered) factor. We can create an ordinal (ordered) factor by using the argument ordered=TRUE. We should be careful with this, though, because while it creates an ordered factor, the levels may not be in the correct order. By default, R places the levels in alphabetical order, which is usually not the order we want for something like medals.\nTo fix this, we can specify the order of the levels using the levels argument. The levels must be spelled exactly the same as the values in the vector, or else missing values will be inserted into the factor.\n\nmedals_ordered &lt;- factor(medals_won, ordered=TRUE)\nmedals_ordered\n\n [1] none   silver bronze silver gold   none   bronze silver bronze bronze\n[11] gold   bronze bronze bronze none   silver none   none   none   gold  \nLevels: bronze &lt; gold &lt; none &lt; silver\n\nmedals_ordered &lt;- factor(medals_won, ordered=TRUE, \n                         levels = c(\"none\", \"bronze\", \"silver\", \"GOLD\"))\n\nmedals_ordered &lt;- factor(medals_won, ordered=TRUE, \n                         levels = c(\"none\", \"bronze\", \"silver\", \"gold\"))\n\nmedals_ordered\n\n [1] none   silver bronze silver gold   none   bronze silver bronze bronze\n[11] gold   bronze bronze bronze none   silver none   none   none   gold  \nLevels: none &lt; bronze &lt; silver &lt; gold\n\n\nLooking at the example above, we can see that a mislabeled level (like “GOLD” instead of “gold”) results in missing values. Once the ordering is set correctly, logical comparisons are now meaningful. For example, it makes sense to say that receiving no medal is “less than” receiving a silver medal.\n\nmedals_ordered[1]\n\n[1] none\nLevels: none &lt; bronze &lt; silver &lt; gold\n\nmedals_ordered[2]\n\n[1] silver\nLevels: none &lt; bronze &lt; silver &lt; gold\n\nmedals_ordered[1] &lt; medals_ordered[2]\n\n[1] TRUE\n\n\nOne more useful skill with factors is renaming the level labels. This can be done by using levels() to view the current levels and then assigning a new character vector of level names (in the same order). This will rename all factor values according to the updated level labels.\n\nlevels(medals_ordered)\n\n[1] \"none\"   \"bronze\" \"silver\" \"gold\"  \n\nlevels(medals_ordered) &lt;- c(\"other\", \"3rd\", \"2nd\", \"1st\")\nmedals_ordered\n\n [1] other 2nd   3rd   2nd   1st   other 3rd   2nd   3rd   3rd   1st   3rd  \n[13] 3rd   3rd   other 2nd   other other other 1st  \nLevels: other &lt; 3rd &lt; 2nd &lt; 1st\n\nlevels(medals_ordered)\n\n[1] \"other\" \"3rd\"   \"2nd\"   \"1st\"  \n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit is tracking the outcome of his weekly quiz grades, but instead of using numbers he labels each attempt as “Proficient”, “Developing”, or “Not-Yet”. Teach Emmit how he can create a vector called quiz_status containing 24 randomly sampled values from those three categories. Explain how he can then convert the vector into a factor and determine how many times each category appears. Finally, show him how to convert it into an ordered factor.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Factors, Dates, and Special Values</span>"
    ]
  },
  {
    "objectID": "Lecture-3-Factors-and-Dates.html#special-values",
    "href": "Lecture-3-Factors-and-Dates.html#special-values",
    "title": "3  Factors, Dates, and Special Values",
    "section": "",
    "text": "Try it Out\n\n\n\nEmmit is cleaning up some data from a sensor that tracks how many steps he takes each day. When he prints the vector, he notices that some values are missing, some values are not real numbers, and some values look infinite. Using the vector below, teach Emmit how he can use R to count how many missing and infinite values are present and report their indices. Then show him how he can compute the mean number of steps Emmit took without the missing values present.\n\nsteps &lt;- c(6200, 7500, NA, 5800, NaN, 8100, Inf, -Inf, 6600)\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Factors, Dates, and Special Values</span>"
    ]
  },
  {
    "objectID": "Lecture-4-Data-Structures-in-R.html#dataframes",
    "href": "Lecture-4-Data-Structures-in-R.html#dataframes",
    "title": "4  Data Structures in R",
    "section": "4.2 Dataframes",
    "text": "4.2 Dataframes\nDataframes are a lot like matrices but differ in that the data does not have to be all of the same type and that every column will describe the same thing while every row will describe an observation. While we will rarely make our own dataframe in R, we can see an example of how this can be done below using the data.frame() function, where we pass vectors of all the same length into the function. In the example we see that the character vector and numeric vector are related to each other, so we decided to put them in a dataframe. Using the str() function, we can identify the structure of the dataframe and see that we have 5 observations (rows) and 2 variables (columns). Likewise, we can see that the “number” vector is a character vector and the “digit” vector is a numeric vector.\n\nnumber &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\ndigit &lt;- c(1,2,3,4,5)\n\nc(typeof(number), typeof(digit))\n\n[1] \"character\" \"double\"   \n\ndf &lt;- data.frame(number, digit)\ndf\n\n  number digit\n1    one     1\n2    two     2\n3  three     3\n4   four     4\n5   five     5\n\nstr(df)\n\n'data.frame':   5 obs. of  2 variables:\n $ number: chr  \"one\" \"two\" \"three\" \"four\" ...\n $ digit : num  1 2 3 4 5\n\n\nWe can see another example of creating a dataframe below. In this example, we use the sample() function to randomly select different names and majors. The rnorm() function is also used to randomly generate the grade using a normal distribution, with the round() function giving us a whole number. We can then see the structure of the dataframe is what we would expect it to be. If we wanted to convert all of the strings to factors then we could use the stringsAsFactors. Notice how with this dataframe the first row describes Claire, who is a Computer Science student, who got a 71 in the course. Meanwhile, the first column describes all of the student’s names, the second column describes all of the student’s majors, and the third column describes all of the student’s grades.\n\nstudents &lt;- c(\"Adam\", \"Bianca\", \"Claire\", \"Dalton\", \"Emmanuel\")\nmajors &lt;- c(\"Data Science\", \"Math\", \"Cyber\", \"Computer Science\")\n\nset.seed(123)\nstudent_sample &lt;- sample(students, 10, replace=TRUE)\nmajor_sample &lt;- sample(majors, 10, replace=TRUE)\ngrade_in_class &lt;- round(rnorm(n=10, mean=70, sd=10))\n\ndf &lt;- data.frame(student_sample, major_sample, grade_in_class)\ndf\n\n   student_sample     major_sample grade_in_class\n1          Claire Computer Science             71\n2          Claire     Data Science             64\n3          Bianca            Cyber             88\n4          Bianca            Cyber             75\n5          Claire     Data Science             50\n6        Emmanuel Computer Science             77\n7          Dalton     Data Science             65\n8            Adam     Data Science             59\n9          Bianca     Data Science             68\n10         Claire            Cyber             60\n\nstr(df)\n\n'data.frame':   10 obs. of  3 variables:\n $ student_sample: chr  \"Claire\" \"Claire\" \"Bianca\" \"Bianca\" ...\n $ major_sample  : chr  \"Computer Science\" \"Data Science\" \"Cyber\" \"Cyber\" ...\n $ grade_in_class: num  71 64 88 75 50 77 65 59 68 60\n\n\nWe can use the dollar sign (\\(\\$\\)) in order to reference a specific column within the dataframe. The referenced column has to be spelled exactly the same way as the column name in the data frame. Note that this result is actually a vector. We will see other methods, later on, to select certain columns and filter the dataframe based on different criteria.\n\ndf$student_sample\n\n [1] \"Claire\"   \"Claire\"   \"Bianca\"   \"Bianca\"   \"Claire\"   \"Emmanuel\"\n [7] \"Dalton\"   \"Adam\"     \"Bianca\"   \"Claire\"  \n\ndf$grade_in_class\n\n [1] 71 64 88 75 50 77 65 59 68 60\n\n\nIf we wish to add on an observation then we can do so with the rbind() function (this stands for row bind). There are two examples below which show this being done. The first one puts all of the values in a vector and then binds it to the bottom of the dataframe. We should be cautious about doing this though, as putting all of the values into a vector first will cause the values to be coerced into a character vector, and then adding it onto the dataframe causes all of the columns to then be coerced into character vectors. This can be seen when we look at the structure of the dataframe. To get around this, we can create a new dataframe with the observation to be added using the same column names. Then we can bind this onto the end of the dataframe. This preserves all of the datatypes currently in the dataframe. Either way will work, it is just something to think about and be cautious of, and you can always use the as.double() or a similar function to coerce the data to be the type you need it to be.\n\ndf &lt;- data.frame(student_sample, major_sample, grade_in_class)\ndf1 &lt;- rbind(df, c(\"Franklin\", \"Politics\", 93))\nstr(df1)\n\n'data.frame':   11 obs. of  3 variables:\n $ student_sample: chr  \"Claire\" \"Claire\" \"Bianca\" \"Bianca\" ...\n $ major_sample  : chr  \"Computer Science\" \"Data Science\" \"Cyber\" \"Cyber\" ...\n $ grade_in_class: chr  \"71\" \"64\" \"88\" \"75\" ...\n\nstudent_added &lt;- data.frame(student_sample = \"Franklin\", \n                            major_sample = \"Politics\", \n                            grade_in_class = 93)\n\ndf2 &lt;- rbind(df, student_added)\nstr(df2)\n\n'data.frame':   11 obs. of  3 variables:\n $ student_sample: chr  \"Claire\" \"Claire\" \"Bianca\" \"Bianca\" ...\n $ major_sample  : chr  \"Computer Science\" \"Data Science\" \"Cyber\" \"Cyber\" ...\n $ grade_in_class: num  71 64 88 75 50 77 65 59 68 60 ...\n\n\nAdditionally, we can add a column to the dataframe using the cbind() function in a similar way to the rbind() function. Or, we could use a dollar sign to reference the “new” column and then assign values to it. We can see how this happens below, with the tail() function being used to show the last 6 observations in the dataframe. The head() function could be used to show the first few observations.\n\ndf2$is_athlete &lt;- sample(c(T, F), 11, replace=TRUE)\ntail(df2)\n\n   student_sample     major_sample grade_in_class is_athlete\n6        Emmanuel Computer Science             77       TRUE\n7          Dalton     Data Science             65       TRUE\n8            Adam     Data Science             59       TRUE\n9          Bianca     Data Science             68       TRUE\n10         Claire            Cyber             60      FALSE\n11       Franklin         Politics             93      FALSE\n\n\nThere are a few other properties and functions relating to dataframes that we should discuss. The first is that we can quickly identify the dimensions (rows and columns) of the dataset using the dim() function. If we want just the number of rows or columns then the nrow() and ncol() functions would be useful. If we wish to alter the column names of the dataframe then the names() function can be used by assigning a new character vector of the same length to it. An example of this can be seen below:\n\ndim(df2)\n\n[1] 11  4\n\nnrow(df2)\n\n[1] 11\n\nncol(df2)\n\n[1] 4\n\nnames(df2)\n\n[1] \"student_sample\" \"major_sample\"   \"grade_in_class\" \"is_athlete\"    \n\nnames(df2) &lt;- c(\"name\", \"major\", \"grade\", \"athlete\")\nhead(df2)\n\n      name            major grade athlete\n1   Claire Computer Science    71    TRUE\n2   Claire     Data Science    64   FALSE\n3   Bianca            Cyber    88    TRUE\n4   Bianca            Cyber    75    TRUE\n5   Claire     Data Science    50   FALSE\n6 Emmanuel Computer Science    77    TRUE",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures in R</span>"
    ]
  },
  {
    "objectID": "Lecture-4-Data-Structures-in-R.html#dataframe-index-selections",
    "href": "Lecture-4-Data-Structures-in-R.html#dataframe-index-selections",
    "title": "4  Data Structures in R",
    "section": "4.3 Dataframe Index Selections",
    "text": "4.3 Dataframe Index Selections\nBeing able to filter your data and look at observations or values that only meet certain criteria is a powerful tool. We previously saw how to do this with one-dimensional vectors. Doing this with two-dimensional dataframes will work the exact same way, with the only difference being that we will need to specify the row and the columns. We must specify the row before the comma and the column after the comma. If no value is provided before or after the comma then it will indicate all rows and all columns being displayed. Additionally, we are also able to pass a vector into the index-selection brackets and display a number of columns or rows at a time. The negative sign (\\(-\\)) will indicate that we should not display those rows/columns.\n\nhead(df, 8)\n\n  student_sample     major_sample grade_in_class\n1         Claire Computer Science             71\n2         Claire     Data Science             64\n3         Bianca            Cyber             88\n4         Bianca            Cyber             75\n5         Claire     Data Science             50\n6       Emmanuel Computer Science             77\n7         Dalton     Data Science             65\n8           Adam     Data Science             59\n\ndf[1,]\n\n  student_sample     major_sample grade_in_class\n1         Claire Computer Science             71\n\ndf[,3]\n\n [1] 71 64 88 75 50 77 65 59 68 60\n\ndf[2,3]\n\n[1] 64\n\ndf[c(1,4,7),]\n\n  student_sample     major_sample grade_in_class\n1         Claire Computer Science             71\n4         Bianca            Cyber             75\n7         Dalton     Data Science             65\n\ndf[c(5,3), -2]\n\n  student_sample grade_in_class\n5         Claire             50\n3         Bianca             88\n\ndf$grade\n\n [1] 71 64 88 75 50 77 65 59 68 60\n\ndf$grade[-4]\n\n[1] 71 64 88 50 77 65 59 68 60\n\n\nIn addition to manually selecting the observations/columns we want to display, we can also use logical vectors to display certain values. Remember before how we were able to use logical operators to obtain a logical vector. So, essentially what we are doing in the examples below is displaying only the observations that meet the given criteria. Notice that we are passing these logical vectors in the “row” index since we only want to display certain rows (observations). Finally, in the second example, we are looking to either have a grade above 70 or be a cyber major. The logical vectors show that in order to be TRUE, either one condition or the other condition has to be met, not both.\n\ndf$grade &gt; 70\n\n [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n\ndf[df$grade &gt; 70,]\n\n  student_sample     major_sample grade_in_class\n1         Claire Computer Science             71\n3         Bianca            Cyber             88\n4         Bianca            Cyber             75\n6       Emmanuel Computer Science             77\n\ndf$grade &gt; 70\n\n [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n\ndf$major == \"Cyber\"\n\n [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n\ndf$grade &gt; 70 | df$major == \"Cyber\"\n\n [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE\n\ndf[df$grade &gt; 70 | df$major == \"Cyber\",]\n\n   student_sample     major_sample grade_in_class\n1          Claire Computer Science             71\n3          Bianca            Cyber             88\n4          Bianca            Cyber             75\n6        Emmanuel Computer Science             77\n10         Claire            Cyber             60\n\n\nIf we wish to remove a row then we can either use the negative sign to select everything but the given row, or we could call the column using the dollar sign and assign the value NULL to it. An example of this can be seen below:\n\ndf$major &lt;- NULL\nhead(df,4)\n\n  student_sample     major_sample grade_in_class\n1         Claire Computer Science             71\n2         Claire     Data Science             64\n3         Bianca            Cyber             88\n4         Bianca            Cyber             75",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures in R</span>"
    ]
  },
  {
    "objectID": "Lecture-4-Data-Structures-in-R.html#lists",
    "href": "Lecture-4-Data-Structures-in-R.html#lists",
    "title": "4  Data Structures in R",
    "section": "4.4 Lists",
    "text": "4.4 Lists\nThe last way we discuss how the data may look will be a list. This allows us to put related variables (matrices, vectors, dataframes, other lists, etc.) into one place even though they don’t “fit together nicely”. In the example below I have put three of the variables we made throughout this lecture into a list using the list() function.\n\nlist_example &lt;- list(x_mat, major_sample, df)\nlist_example\n\n[[1]]\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n[[2]]\n [1] \"Computer Science\" \"Data Science\"     \"Cyber\"            \"Cyber\"           \n [5] \"Data Science\"     \"Computer Science\" \"Data Science\"     \"Data Science\"    \n [9] \"Data Science\"     \"Cyber\"           \n\n[[3]]\n   student_sample     major_sample grade_in_class\n1          Claire Computer Science             71\n2          Claire     Data Science             64\n3          Bianca            Cyber             88\n4          Bianca            Cyber             75\n5          Claire     Data Science             50\n6        Emmanuel Computer Science             77\n7          Dalton     Data Science             65\n8            Adam     Data Science             59\n9          Bianca     Data Science             68\n10         Claire            Cyber             60\n\nstr(list_example)\n\nList of 3\n $ : int [1:3, 1:4] 1 5 9 2 6 10 3 7 11 4 ...\n $ : chr [1:10] \"Computer Science\" \"Data Science\" \"Cyber\" \"Cyber\" ...\n $ :'data.frame':   10 obs. of  3 variables:\n  ..$ student_sample: chr [1:10] \"Claire\" \"Claire\" \"Bianca\" \"Bianca\" ...\n  ..$ major_sample  : chr [1:10] \"Computer Science\" \"Data Science\" \"Cyber\" \"Cyber\" ...\n  ..$ grade_in_class: num [1:10] 71 64 88 75 50 77 65 59 68 60\n\n\nLooking at the last command above, we can see that the structure of the list is in fact a list. It shows us that we have an integer matrix, a character vector, and a dataframe. If we want to reference an item in the list then we can use the index selection brackets. Using 1 bracket as seen below does not actually give us the item, rather it still gives us a list of the item. We can see this based on the “[[1]]” at the top of the output, indicating that we are still dealing with a list. Looking at the structure also shows us that this is going on. To avoid this issue, we can use double brackets to output the item from the list. The outputs below have been slightly altered for space reasons.\n\nlist_example[3]\n\n[[1]]\n   student_sample     major_sample grade_in_class\n1          Claire Computer Science             71\n2          Claire     Data Science             64\n3          Bianca            Cyber             88\n4          Bianca            Cyber             75\n5          Claire     Data Science             50\n6        Emmanuel Computer Science             77\n7          Dalton     Data Science             65\n8            Adam     Data Science             59\n9          Bianca     Data Science             68\n10         Claire            Cyber             60\n\nstr(list_example[3])\n\nList of 1\n $ :'data.frame':   10 obs. of  3 variables:\n  ..$ student_sample: chr [1:10] \"Claire\" \"Claire\" \"Bianca\" \"Bianca\" ...\n  ..$ major_sample  : chr [1:10] \"Computer Science\" \"Data Science\" \"Cyber\" \"Cyber\" ...\n  ..$ grade_in_class: num [1:10] 71 64 88 75 50 77 65 59 68 60\n\nlist_example[[3]]\n\n   student_sample     major_sample grade_in_class\n1          Claire Computer Science             71\n2          Claire     Data Science             64\n3          Bianca            Cyber             88\n4          Bianca            Cyber             75\n5          Claire     Data Science             50\n6        Emmanuel Computer Science             77\n7          Dalton     Data Science             65\n8            Adam     Data Science             59\n9          Bianca     Data Science             68\n10         Claire            Cyber             60\n\nstr(list_example[[3]])\n\n'data.frame':   10 obs. of  3 variables:\n $ student_sample: chr  \"Claire\" \"Claire\" \"Bianca\" \"Bianca\" ...\n $ major_sample  : chr  \"Computer Science\" \"Data Science\" \"Cyber\" \"Cyber\" ...\n $ grade_in_class: num  71 64 88 75 50 77 65 59 68 60\n\n\nFinally, if we are dealing with lists then we may want to have the items be called something. To give the items names or even change the names we can use the names() function and pass a character vector to it. This is beneficial as we will know what each item is along with being able to reference the item by name instead of using the double index selection brackets. Again, the output has been slightly altered for space reasons.\n\nnames(list_example)\n\nNULL\n\nnames(list_example) &lt;- c(\"x_matrix\", \"majors\", \"class_df\")\nlist_example\n\n$x_matrix\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n$majors\n [1] \"Computer Science\" \"Data Science\"     \"Cyber\"            \"Cyber\"           \n [5] \"Data Science\"     \"Computer Science\" \"Data Science\"     \"Data Science\"    \n [9] \"Data Science\"     \"Cyber\"           \n\n$class_df\n   student_sample     major_sample grade_in_class\n1          Claire Computer Science             71\n2          Claire     Data Science             64\n3          Bianca            Cyber             88\n4          Bianca            Cyber             75\n5          Claire     Data Science             50\n6        Emmanuel Computer Science             77\n7          Dalton     Data Science             65\n8            Adam     Data Science             59\n9          Bianca     Data Science             68\n10         Claire            Cyber             60\n\nlist_example$class_df\n\n   student_sample     major_sample grade_in_class\n1          Claire Computer Science             71\n2          Claire     Data Science             64\n3          Bianca            Cyber             88\n4          Bianca            Cyber             75\n5          Claire     Data Science             50\n6        Emmanuel Computer Science             77\n7          Dalton     Data Science             65\n8            Adam     Data Science             59\n9          Bianca     Data Science             68\n10         Claire            Cyber             60",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures in R</span>"
    ]
  }
]