[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data-210-Book",
    "section": "",
    "text": "Welcome\nWelcome to Exploratory Data Analysis!\nThis online book is designed to guide you step by step as you build both the technical skills and the critical thinking needed to work with data. Along the way, you’ll learn how to ask good questions, organize and analyze information in R, and communicate your findings clearly to others.\nThe chapters are filled with examples, practice problems, and short stories about Emmit — a character you’ll get to know as you apply your skills in fun and practical ways. Each section is scaffolded to help you practice, reflect, and gain confidence as you progress. Additionally, there are downloadable reading guides and activities to assist you in your learning journey.\nWhether you’re brand new to programming, statistics, or data science, or you’ve had some experience before, this book is meant to meet you where you are and help you grow. By the end, you’ll not only understand the concepts but also feel confident using them in real-world situations.\n\nNote\nThis textbook was written by Dr. Jon McCurdy for Mount St. Mary’s University’s Exploratory Data Analysis course. Special Thanks to student Luke Papayoanou for his input along with developing the MSMU package in R to go along with this book.\n\n\n\n\n Dr. Jon McCurdy\n\n\n Luke Papayoanou",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html",
    "href": "Lecture-1-R-Fundamentals-Review.html",
    "title": "1  R Fundamentals Review",
    "section": "",
    "text": "1.1 Using R as a Computer\nThe aim of this lecture is to provide a review of R along with RMarkdown. While you should have seen most of this material before, it will be beneficial to have a refresher. As you go through this lecture write-up, I encourage you to run the code in your own R Console. Once you are comfortable with the material try and make slight change to the code and see how that effects the results. This will help you truly understand what is going on.\nWhen we first started using R, we emphasized thinking of R as a calculator. Any mathematical operation we want to do can most likely be done in R. The code below shows how we can do addition, subtraction, multiplication, and division.\n13 + 29\n\n[1] 42\n\n(4 + 145*2)/(5 + 2^(3 + 1))\n\n[1] 14\nR also supports exponents, modular division using the %% operator (which returns the remainder), and integer division using the %/% operator (which can be thought of as the floor of the division). Below, we can see how these operations are related.\n27/5\n\n[1] 5.4\n\n27 %/% 5 # This gives how many times 5 goes into 27\n\n[1] 5\n\n27 %% 5 # This gives us the remainder after dividing 27 by 5\n\n[1] 2\n\n(27 %/% 5) + (27 %% 5)/5 # This shows how we can carry out division\n\n[1] 5.4\nAs you type expressions into R, it is important to think carefully about the order of operations. R follows the standard PEMDAS rules, but it is still easy to enter an expression in a way that produces unintended results. For this reason, you should always use parentheses whenever you are performing calculations in the numerator, denominator, or exponent to ensure the expression is evaluated as intended. Keep in mind that R ignores spaces in code, so placing numbers close together does not change the order in which operations are performed. R will always follow PEMDAS unless parentheses explicitly tell it otherwise. The examples below illustrate why parentheses are so important.\n3+4 / 2\n\n[1] 5\n\n(3+4) / 2\n\n[1] 3.5\n\n2^ 6/3\n\n[1] 21.33333\n\n2^ (6/3)\n\n[1] 4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html",
    "href": "Lecture-2-Strings-and-Text-Processing.html",
    "title": "2  Text Processing and Useful R Tools",
    "section": "",
    "text": "2.1 More Complex Logical Selections\nThis lecture will continue our review of R while also introducing some new functions and commands that you may not have seen before. As we go through the examples, it is important to run the code in your own R console in order to truly understand what the code is doing. Additionally, as you type the code, you should think about what the output will be before running the command. This will help you develop the critical thinking and programming skills needed to continue improving as a programmer. Finally, if you are unsure what the code is doing, try breaking it down into smaller sections (if applicable) or creating a simpler example.\nWe previously saw how logical operators can be used for index selection to identify values that meet certain criteria. We can expand this idea by creating more complex conditions using multiple logical comparisons. In particular, we can use the ampersand \\((\\&)\\) to represent an “AND” condition, the pipe \\((|)\\) to represent an “OR” condition, and the exclamation mark (!) to represent “NOT”. The ! operator flips logical values, turning TRUE into FALSE and FALSE into TRUE.\nBelow are a few examples showing how these logical operators work. As a reminder, we can do “math” on logical vectors because FALSE is treated as 0 and TRUE is treated as 1. This allows us to count how many values meet a condition using the sum() function.\nx &lt;- 1:11\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11\n\nx &lt; 6\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\nsum(x &lt; 6)\n\n[1] 5\n\nx[x &lt; 6]\n\n[1] 1 2 3 4 5\nIn the example below, we use logical operators to create compound statements. For example, we can display all values that are less than 5 OR greater than 9, as well as all values that are greater than 3 AND less than or equal to 8.\nx &lt; 5 | x &gt; 9\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\nx[x &lt; 5 | x &gt; 9]\n\n[1]  1  2  3  4 10 11\n\nx &gt; 3 & x &lt;= 8\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nx[x &gt; 3 & x &lt;= 8]\n\n[1] 4 5 6 7 8\nThe last major logical operator is the NOT operator, which flips a logical condition. This is useful when we want to select all values that do not meet a certain requirement, such as displaying all values that are not greater than or equal to 7.\nc(!TRUE, !FALSE)\n\n[1] FALSE  TRUE\n\n!(x &gt;= 7)\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx[!(x &gt;= 7)]\n\n[1] 1 2 3 4 5 6",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-3-Factors-and-Dates.html",
    "href": "Lecture-3-Factors-and-Dates.html",
    "title": "3  Factors and Dates",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Factors and Dates</span>"
    ]
  },
  {
    "objectID": "Lecture-4-Data-Structures-in-R.html",
    "href": "Lecture-4-Data-Structures-in-R.html",
    "title": "4  Data Structures in R",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures in R</span>"
    ]
  },
  {
    "objectID": "Lecture-5-Control-Flow-and-Functions.html",
    "href": "Lecture-5-Control-Flow-and-Functions.html",
    "title": "5  Control Flow and Functions",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Flow and Functions</span>"
    ]
  },
  {
    "objectID": "Lecture-6-Data-Visualization-with-ggplot.html",
    "href": "Lecture-6-Data-Visualization-with-ggplot.html",
    "title": "6  Data Visualization with ggplot",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Visualization with ggplot</span>"
    ]
  },
  {
    "objectID": "Lecture-7-Data-Wrangling-with-dplyr.html",
    "href": "Lecture-7-Data-Wrangling-with-dplyr.html",
    "title": "7  Data Wrangling with dplyr",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Wrangling with dplyr</span>"
    ]
  },
  {
    "objectID": "Lecture-8-Grouped-and-Bivariate-Analysis.html",
    "href": "Lecture-8-Grouped-and-Bivariate-Analysis.html",
    "title": "8  Grouped and Bivariate Analysis",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grouped and Bivariate Analysis</span>"
    ]
  },
  {
    "objectID": "Lecture-9-Handling-Missing-Data.html",
    "href": "Lecture-9-Handling-Missing-Data.html",
    "title": "9  Handling Missing Data",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Handling Missing Data</span>"
    ]
  },
  {
    "objectID": "Lecture-10-Tidy-Data-Principles.html",
    "href": "Lecture-10-Tidy-Data-Principles.html",
    "title": "10  Tidy Data Principles",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Tidy Data Principles</span>"
    ]
  },
  {
    "objectID": "Lecture-11-Distributions-Across-Groups.html",
    "href": "Lecture-11-Distributions-Across-Groups.html",
    "title": "11  Distributions Across Groups",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Distributions Across Groups</span>"
    ]
  },
  {
    "objectID": "Lecture-12-Sampling-and-CLT.html",
    "href": "Lecture-12-Sampling-and-CLT.html",
    "title": "12  Sampling and CLT",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Sampling and CLT</span>"
    ]
  },
  {
    "objectID": "Lecture-13-Confidence-Intervals-and-Comparisons.html",
    "href": "Lecture-13-Confidence-Intervals-and-Comparisons.html",
    "title": "13  Confidence Intervals and Comparisons",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Confidence Intervals and Comparisons</span>"
    ]
  },
  {
    "objectID": "Lecture-14-Hypothesis-Testing-Foundations.html",
    "href": "Lecture-14-Hypothesis-Testing-Foundations.html",
    "title": "14  Hypothesis Testing Foundations",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Hypothesis Testing Foundations</span>"
    ]
  },
  {
    "objectID": "Lecture-15-Comparing-Means-and-Groups.html",
    "href": "Lecture-15-Comparing-Means-and-Groups.html",
    "title": "15  Comparing Means and Groups",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Comparing Means and Groups</span>"
    ]
  },
  {
    "objectID": "Lecture-16-Categorical-Data-Inference.html",
    "href": "Lecture-16-Categorical-Data-Inference.html",
    "title": "16  Categorical Data Inference",
    "section": "",
    "text": "Under Construction",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Categorical Data Inference</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#vectors",
    "href": "Lecture-1-R-Fundamentals-Review.html#vectors",
    "title": "1  R Fundamentals Review",
    "section": "1.2 Vectors",
    "text": "1.2 Vectors\nIt is important to remember that everything in R is vectorized. This includes single elements along with what we would traditionally call a vector (a combination of elements into a single group). To make a vector, we can use the c() function. To save a vector to a variable for later use, you will need to use the assignment operator (\\(&lt;\\)–), which assigns the value on the right to the variable name on the left (the value is pointing to the name).\n\nis.vector(3)\n\n[1] TRUE\n\ntest_vector &lt;- c(7, 2, 6, 9, 3, 6.43, -3, 3/2)\ntest_vector\n\n[1]  7.00  2.00  6.00  9.00  3.00  6.43 -3.00  1.50\n\nis.vector(test_vector)\n\n[1] TRUE\n\n\nWhen doing math on vectors, R performs the operation element by element (meaning the math is done on the first element of each vector, then the second element of each vector, and so on). If the vectors are of different lengths, R recycles the shorter vector until the operation has been performed on all elements of the longer vector. If the vector lengths are not multiples of each other, the operation will still be performed until the longer vector is fully “used”, but R will issue a warning message letting you know about the issue.\n\na &lt;- c(0,5,10)\nb &lt;- c(3,7,-2)\na * 2\n\n[1]  0 10 20\n\na+b # Does 3+0, 5+7, 10+(-2)\n\n[1]  3 12  8\n\na &lt;- c(0, 5, 10)\nb &lt;- c(20, 30)\na+b # Does 0+20, 5+30, 10+20\n\nWarning in a + b: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 20 35 30\n\n\nWe can also create vectors containing character elements (as long as they are in quotes) as well as vectors containing logical elements. For the logical elements, we can either type it in all capital letters or abbreviate it using the first letter.\n\nchar_vector &lt;- c(\"This is\", \"also\", \"a\", \"vector\", \"of characters\")\nchar_vector\n\n[1] \"This is\"       \"also\"          \"a\"             \"vector\"       \n[5] \"of characters\"\n\nc(T, T, FALSE, TRUE, F)\n\n[1]  TRUE  TRUE FALSE  TRUE FALSE\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit tracks his number of steps each day for one week, which were: 4,552, 7,324, 9,642, 5,304, 2,049, 6,424, and 13,284. Teach Emmit how to save these step counts as a vector in R. If he believes he can increase his steps by 15%, how can he determine the number of steps he would need to take each day?\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#data-types",
    "href": "Lecture-1-R-Fundamentals-Review.html#data-types",
    "title": "1  R Fundamentals Review",
    "section": "1.3 Data Types",
    "text": "1.3 Data Types\nAnother important idea to remember is that all objects in R have a data type. We will mainly encounter doubles (numbers), logicals (TRUE/FALSE), and characters (anything in quotes). We can determine the type of data we are working with by using the typeof() function. This will be important for us when we start trying to analyze/troubleshoot our code, as we cannot perform mathematical operations on a character vector, even if all of the characters themselves are numbers.\n\ntypeof(4.25) # Shows 4.25 is a double\n\n[1] \"double\"\n\ntypeof(FALSE) # Shows FALSE is a logical\n\n[1] \"logical\"\n\ntypeof(\"4.25\") # Shows \"4.25\" is a character because it is in quotes\n\n[1] \"character\"\n\n\nAnother reason it is important to think about data types is because a vector will automatically be coerced to the “lowest” common type present (character \\(&lt;\\) double \\(&lt;\\) logical). That is to say, if a vector has a single character element all of the values will be turned into characters. Likewise, if a vector consists of doubles and logicals then the vector will be presented as doubles. We can explicitly coerce a vector to a specific type using functions such as as.numeric() or as.character(). This process can be seen below.\n\nc(1, 2, 3, 4, 5)\n\n[1] 1 2 3 4 5\n\ntypeof(c(1, 2, 3, 4, 5))\n\n[1] \"double\"\n\nx &lt;- c(1, 2, 3, 4, \"5\")\nx\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\ntypeof(x)\n\n[1] \"character\"\n\nis.numeric(x)\n\n[1] FALSE\n\nis.character(x)\n\n[1] TRUE\n\nas.numeric(x) # Converting the character vector to be numeric\n\n[1] 1 2 3 4 5\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen coercing a vector to numeric using as.numeric(), any values that cannot be converted will become NA\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit’s fitness tracker recorded several pieces of information for a single day. His step count was 6,424 steps, the tracker recorded that he worked out that day (TRUE), and he added the note “Leg day” to describe his workout. Teach Emmit how to check the data type of each of these values in R. Then, combine the step count and the note into a single vector and determine the data type of the resulting vector. Explain to him why this data type occurs.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#built-in-functions-in-r",
    "href": "Lecture-1-R-Fundamentals-Review.html#built-in-functions-in-r",
    "title": "1  R Fundamentals Review",
    "section": "1.4 Built-in Functions in R",
    "text": "1.4 Built-in Functions in R\nThere are several built-in functions in base R that are useful for working with numeric data. These include mean(), median(), sd(), min(), max(), sqrt(), length(), and many more. All of these functions require an input, which is typically provided as a vector. If we forget to pass the values as a vector, the function may still run, but not in the way you would expect. In the example below, mean(4, 36, 25, 9, 16) returns 4 because mean() treats the first value as the data and interprets the remaining values as additional arguments, which are ignored.\n\ny &lt;- c(4,36, 25, 9, 16)\nmean(y)\n\n[1] 18\n\nmean(4,36, 25, 9, 16)\n\n[1] 4\n\n\nAs you look at the following functions, note that different functions return different types of output. Some functions return a single value:\n\nsum(y)\n\n[1] 90\n\nlength(y)\n\n[1] 5\n\nmedian(y)\n\n[1] 16\n\nsd(y)\n\n[1] 12.78671\n\n\nWe can also combine functions to compute new values, such as the mean:\n\nsum(y)/length(y)\n\n[1] 18\n\n\nOther functions return a vector with the same number of elements as the input:\n\nsort(y)\n\n[1]  4  9 16 25 36\n\nsqrt(y)\n\n[1] 2 6 5 3 4\n\n\nFinally, some functions return multiple values:\n\nmin(y)\n\n[1] 4\n\nmax(y)\n\n[1] 36\n\nrange(y)\n\n[1]  4 36\n\n\nFinally, we can apply function to the results of functions as well:\n\ndiff(range(y))\n\n[1] 32\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf a vector contains missing values (NA), many built-in functions will return NA by default. You can remove missing values from the calculation by including na.rm = TRUE inside the function.\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit recorded his daily step counts for one week as the values 4,552, 7,324, 9,642, 5,304, 2,049, 6,424, and 13,284. Using built-in R functions, teach Emmit how to calculate the total number of steps he took during the week, his average number of steps per day, his minimum and maximum daily step counts, and a measure of how spread out his step counts are.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#logical-operators-and-index-selection",
    "href": "Lecture-1-R-Fundamentals-Review.html#logical-operators-and-index-selection",
    "title": "1  R Fundamentals Review",
    "section": "1.5 Logical Operators and Index Selection",
    "text": "1.5 Logical Operators and Index Selection\nBesides just carrying out mathematical operations, it is also useful to use logical operators to select only certain values or determine how many values meet certain criteria. These logical operators include less than \\((&lt;)\\), greater than \\((&gt;)\\), equal to \\((==)\\), and not equal to \\((!=)\\). We can also use less than or equal to \\((&lt;=)\\) and greater than or equal to \\((&gt;=)\\).\nSometimes it is helpful to display only the values that meet certain criteria, which can be done using index selection. To do this, we call the vector and then use index selection brackets to specify which elements we want to display. Logical operators are especially useful here because their output is a logical vector, which can be passed directly into the index selection brackets.\n\nx &lt;- c(2, 5, 7, 3, 1, 5, 8, 3)\nx\n\n[1] 2 5 7 3 1 5 8 3\n\n\n\nx == 3\n\n[1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n\nsum(x == 3) # Cunts the number of TRUEs\n\n[1] 2\n\nx[x == 3]\n\n[1] 3 3\n\nlength(x[x == 3]) # Counts the number of values meeting the criteria\n\n[1] 2\n\nx &lt; 5\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\nx[x &lt; 5] # Displaying only the values that are less than 5\n\n[1] 2 3 1 3\n\n\nUsing a negative sign indicates that we want all elements except the specified indices.\n\nx[c(1,4,6)]\n\n[1] 2 3 5\n\nx[-c(1,4,6)]\n\n[1] 5 7 1 8 3\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nUsing Emmit’s weekly step counts of 4,552, 7,324, 9,642, 5,304, 2,049, 6,424, and 13,284, Emmit decides that a day counts as a “good workout day” if he takes more than 7,000 steps. Teach Emmit how to use logical operators and index selection in R to identify which days meet this criterion, count how many good workout days he had during the week, and display only the step counts from those days.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#r-markdown",
    "href": "Lecture-1-R-Fundamentals-Review.html#r-markdown",
    "title": "1  R Fundamentals Review",
    "section": "1.6 R Markdown",
    "text": "1.6 R Markdown\nAs we progress as data scientists, it is important to organize our code in a cohesive way that supports reproducibility. One of the best ways to do this is by writing our work in an R Markdown document. R Markdown allows us to keep our code, output, and written explanations all in one place. When we are finished, we can “knit” the document into a final report that displays both the code we wrote and the output directly beneath it. This approach makes it easy to update results by changing the code, without needing to copy and paste output manually.\nTo create an R Markdown document, open RStudio and select File -\\(&gt;\\) New File -\\(&gt;\\) R Markdown. You will be prompted to enter a document title and choose an output format. For this class, you should knit your documents as PDFs, so you will select that option. The first time you knit a PDF, RStudio may ask you to install a TeX distribution; this can be done directly through R and only needs to be installed once. To do so, you may need to install TinyTeX by running install.packages(\"tinytex\"), loading it with library(tinytex), and then installing the TeX distribution using tinytex::install_tinytex(), after which you should be able to knit the file as a PDF.\nAt the top of the document, you will see a header (the content between the — lines). This header contains information such as the title, author, date, and output format. You generally do not need to edit the output format manually, as knitting the document will automatically update it depending on whether you knit to PDF, HTML, or Word. Near the top of the file, you will also see an R setup chunk. This chunk should remain at the top of the document and is commonly used for code that should run but not appear in the final output, such as loading libraries or importing data. This behavior occurs because the chunk includes the argument include = FALSE.\nEverything below the setup chunk can be deleted before you begin working, as the default content is not needed for this course. When you are ready to write code, you will create an R chunk. This can be done manually or by clicking the green C button near the top of the editor and selecting R. All code should be written inside these chunks (not the output). While working, you can run the code in a chunk by clicking the green play button in the top-right corner of the chunk. If this button is missing, make sure the chunk’s triple backticks have not been accidentally deleted.\nAny written explanations or comments describing what you are doing should be placed outside of code chunks in the white space of the document. This is where you should describe the problem and explain your results. Avoid placing long comments inside R chunks, as they can make the code difficult to read. You can also organize your document using headers by starting a line with the pound sign (#). Using multiple pound signs creates subheaders. Be sure to leave a blank line before and after each header.\nOnce you are satisfied with your document, you can knit it to a PDF by clicking the “Knit” button near the top of the editor. If an error is present, the document will not knit successfully, and RStudio will indicate which chunk caused the issue and why. These errors are usually straightforward to fix—just be sure to carefully read the error message.\n\n\nLecture Video\n\n\n\nIn-Class Exercises\n\n\nIn-Class Exercises Video Solutions\n\n\n\nProblem Set Questions",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-1-R-Fundamentals-Review.html#using-r-as-a-computer",
    "href": "Lecture-1-R-Fundamentals-Review.html#using-r-as-a-computer",
    "title": "1  R Fundamentals Review",
    "section": "",
    "text": "Try it Out\n\n\n\nEmmit is planning his weekly expenses and wants to calculate how much money he has left after buying groceries, gas, and coffee. He typically has $100 to spend each week. So far, he has paid $30 for gas, split a $72 grocery bill with two other friends, and bought a $4 coffee three times. Teach Emmit how he can determine how much money he has left for the week using R.\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals Review</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#identifying-patterns-using-grep-and-grepl",
    "href": "Lecture-2-Strings-and-Text-Processing.html#identifying-patterns-using-grep-and-grepl",
    "title": "2  Text Processing and Useful R Tools",
    "section": "2.2 Identifying patterns using grep() and grepl()",
    "text": "2.2 Identifying patterns using grep() and grepl()\nAnother powerful way to identify values meeting certain criteria is to use the grep() or grepl() function. These functions allow us to identify patterns within character vectors. Both functions work in the same way, but they return different types of output: grep() returns the indices that match the pattern, while grepl() returns a logical vector indicating which values match. The function works by passing in a pattern that we wish to search for along with the vector that we are searching through, such as grep(\"pattern\", x).\nIt should be noted that patterns are case sensitive, meaning \"H\" will only identify elements containing a capital H, not a lowercase h. If we wish to search at the beginning of a string, we can use the caret \\(\\wedge\\). For example, the pattern $^Happy will identify all elements that start with \"Happy\" and will not match it if it appears later in the string.\n\ngreetings &lt;- c(\"Happy Birthday\", \"Merry Christmas\", \"Trick or Treat\", \n              \"Happy Holidays\",\"That makes me Happy\")\ngreetings\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\ngrep(\"Happy\", greetings)\n\n[1] 1 4 5\n\ngreetings[grep(\"Happy\", greetings)]\n\n[1] \"Happy Birthday\"      \"Happy Holidays\"      \"That makes me Happy\"\n\ngrepl(\"Happy\", greetings)\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE\n\ngreetings[grepl(\"Happy\", greetings)]\n\n[1] \"Happy Birthday\"      \"Happy Holidays\"      \"That makes me Happy\"\n\ngrep(\"^Happy\", greetings)\n\n[1] 1 4\n\ngreetings[grep(\"^Happy\", greetings)]\n\n[1] \"Happy Birthday\" \"Happy Holidays\"\n\n\nWe can also identify elements that end with a certain pattern using the dollar sign ($). For example, the pattern s$ will identify all elements that end with the letter \"s\". Additionally, we can use brackets to indicate that we want to match any one of the characters inside the brackets. For instance, the pattern [ioa]n will match \"in\", \"on\", or \"an\" anywhere in the string. If we want to match any character, we can use a period (.). For example, the pattern t. will match the letter \"t\" followed by any single character.\n\ngreetings\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\ngrep(\"s$\", greetings)\n\n[1] 2 4\n\ngreetings[grep(\"s$\", greetings)]\n\n[1] \"Merry Christmas\" \"Happy Holidays\" \n\ngrep(\"[sa]t\", greetings)\n\n[1] 2 3 5\n\ngreetings[grep(\"[sa]t\", greetings)]\n\n[1] \"Merry Christmas\"     \"Trick or Treat\"      \"That makes me Happy\"\n\ngrep(\"t.\", greetings)\n\n[1] 1 2 5\n\ngreetings[grep(\"t.\", greetings)]\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"That makes me Happy\"\n\n\nWhile these patterns may seem confusing or even a little intimidating at first, they are very powerful tools that we should become familiar with. A good way to practice is to create small examples and give yourself a simple goal. Since the example is small, it will be easy to check whether the output matches what you expected. Practicing like this will help you understand the function while also reinforcing an important troubleshooting skill: simplifying the problem.\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit wrote workout notes in the character vector below. Teach Emmit how to use grep() to find the indices of the notes that contain the pattern \"Run\", and then display only those matching notes. Also, teach Emmit how to use grepl() to produce a logical vector for the same pattern and to display the values. Finally, have Emmit identify which notes start with \"Rest\".\n\nnotes &lt;- c(\"Run 2 miles\", \"Rest day\", \"Leg day\", \"Walk 30 min then Rest\", \"Run intervals\", \n           \"Upper body\", \"Rest and stretch\", \"Bike 10 miles\", \"run 1 mile\", \"Run fast\")\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#substituting-patterns-using-sub-and-gsub",
    "href": "Lecture-2-Strings-and-Text-Processing.html#substituting-patterns-using-sub-and-gsub",
    "title": "2  Text Processing and Useful R Tools",
    "section": "2.3 Substituting patterns using sub() and gsub()",
    "text": "2.3 Substituting patterns using sub() and gsub()\nTwo functions related to grep() is sub() and gsub(). These functions search for a pattern (like grep()) and then replace it with another specified pattern. This is especially helpful when cleaning data and preparing it to be analyzed. To use these functions, we provide three inputs: the pattern we want to identify, the replacement pattern, and the vector we want to modify. Both sub() and gsub() work the same way, but sub() only replaces the first occurrence of the pattern in each element, while gsub() replaces every occurrence.\nWe can also use some of the same pattern commands we learned with grep(), such as using ^ to represent the beginning of a string and $ to represent the end of a string. The function works as follows: sub(\"pattern to identify\", \"replacement pattern\", x). Note that sub() and gsub() do not permanently change the original vector unless you save the result to a variable.\n\ngreetings &lt;- c(\"Happy Birthday\", \"Merry Christmas\", \"Trick or Treat\", \n               \"Happy Holidays\",\"That makes me Happy\")\ngreetings\n\n[1] \"Happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\n\nIn the code below, we identify the \"H\" pattern and replace it with a lowercase version. You can see that sub() will only make the replacement on the first occurrence within each element while gsub() will carry out the replacement for every occurrence within each element.\n\nsub(\"H\", \"h\", greetings)\n\n[1] \"happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"happy Holidays\"      \"That makes me happy\"\n\ngsub(\"H\", \"h\", greetings)\n\n[1] \"happy Birthday\"      \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"happy holidays\"      \"That makes me happy\"\n\n\nThis might be beneficial if we need to replace a word or substring. The code below shows how we replace the pattern \"Birthday\" with \"New Year!\".\n\nsub(\"Birthday\", \"New Year!\", greetings)\n\n[1] \"Happy New Year!\"     \"Merry Christmas\"     \"Trick or Treat\"     \n[4] \"Happy Holidays\"      \"That makes me Happy\"\n\n\nWe can get creative with the way we identify patterns and make alterations. In one of the lines of code below, we identify the end of the pattern and replace the ending with an exclamation mark. In another line we identify the beginning of the pattern and replace it with the phrase \"Hi, \". Finally, on the last line we identify any spaces and replace them with nothing (essentially removing the spaces).\n\nsub(\"$\", \"!\", greetings)\n\n[1] \"Happy Birthday!\"      \"Merry Christmas!\"     \"Trick or Treat!\"     \n[4] \"Happy Holidays!\"      \"That makes me Happy!\"\n\nsub(\"^\", \"Hi, \", greetings)\n\n[1] \"Hi, Happy Birthday\"      \"Hi, Merry Christmas\"    \n[3] \"Hi, Trick or Treat\"      \"Hi, Happy Holidays\"     \n[5] \"Hi, That makes me Happy\"\n\ngsub(\" \", \"\", greetings)\n\n[1] \"HappyBirthday\"    \"MerryChristmas\"   \"TrickorTreat\"     \"HappyHolidays\"   \n[5] \"ThatmakesmeHappy\"\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit’s workout notes are inconsistent, so he stored them in the vector below. Teach Emmit how to use sub() to replace the first occurrence of \"Workout\" with \"Session\" in each element of the vector. Then teach Emmit how to use gsub() to replace every occurrence of \"min\" with \"minutes\".\n\nmessy &lt;- c(\"Workout: Run 2 miles\", \"Workout: Run 10 min Walk 30 min\", \n           \"Workout: Leg day\", \"Workout: Rest day\", \"Workout: Run 25 min\")\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#special-functions-in-r",
    "href": "Lecture-2-Strings-and-Text-Processing.html#special-functions-in-r",
    "title": "2  Text Processing and Useful R Tools",
    "section": "2.4 Special Functions in R",
    "text": "2.4 Special Functions in R\nThere are a few additional special functions that we will continue to use throughout this course. The first one we should discuss is the sample() function. This function takes an input vector and randomly samples values from it. If more values are requested than are in the original vector, then an error message will appear (for example, we cannot select 15 items if there are only 10 available). In order to sample more values than the vector contains, we need to sample with replacement by using replace = TRUE. If we want to get the same results every time we run sample(), we need to set the random seed using the set.seed() function. This ensures that the pseudo-random number generator produces the same sequence of results each time.\nIn the code below, we can see that running sample() multiple times produces different results.\n\nabc &lt;- letters[1:10]\nabc\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"\n\nsample(abc, 5)\n\n[1] \"a\" \"j\" \"b\" \"d\" \"e\"\n\nsample(abc, 5)\n\n[1] \"h\" \"j\" \"a\" \"c\" \"f\"\n\n\nIf we try to sample more values than are present, we get an error. To fix this, we specify replace = TRUE to allow sampling to be done with replacement (which allows duplicate values).\n\nsample(abc, 15)\n\nError in sample.int(length(x), size, replace, prob) : cannot take a sample larger than the population when 'replace = FALSE'\n\nsample(abc, 15, replace=TRUE)\n\n [1] \"f\" \"g\" \"b\" \"a\" \"i\" \"f\" \"f\" \"c\" \"b\" \"b\" \"f\" \"g\" \"b\" \"g\" \"a\"\n\n\nIf we want reproducible values, then we need to set the seed. If you want to think about it like a book filled with random numbers, setting the seed makes sure you start reading the numbers off the same page. We can see an example of this below.\n\nset.seed(123)\nsample(abc, 5)\n\n[1] \"c\" \"j\" \"b\" \"h\" \"f\"\n\nset.seed(123)\nsample(abc, 5)\n\n[1] \"c\" \"j\" \"b\" \"h\" \"f\"\n\nsample(abc, 5)\n\n[1] \"e\" \"d\" \"f\" \"h\" \"a\"\n\n\nAnother function that is important for us to have experience with is the which() function. This function (much like grep()) tells us which indices meet a logical condition. This can be helpful when we want the output to be indices instead of a vector of TRUE and FALSE values. Examples of using the which() function can be seen below, including one example that identifies which values are even by checking which elements have a remainder of 0 when divided by 2.\n\nnum &lt;- sample(1:15, size=10, replace=TRUE)\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\nwhich(num &gt; 10)\n\n[1]  2  5  7 10\n\nnum[which(num &gt; 10)]\n\n[1] 11 11 12 13\n\nwhich(num %% 2 == 0)\n\n[1] 1 7\n\nnum[which(num %% 2 == 0)]\n\n[1] 10 12\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit wants to randomly choose 7 workouts from the vector below to build a weekly plan. Teach Emmit how to use sample() to select 7 workouts so he gets the same random results each time he runs the code. After that, Emmit tracks his workout minutes for the week using the vector below and wants to know which days were longer than 60 minutes. Teach Emmit how this can be done in R.\n\nworkouts &lt;- c(\"Run\", \"Walk\", \"Bike\", \"Swim\")\ndaily_mins &lt;- c(25, 70, 45, 10, 65, 80, 35)\n\n\n\nClick to see the solution\n\n\n\n\n\nThe match() function may also be of some use to us throughout the semester. It returns the index position of each value in the first vector within the second vector (and returns NA if a value is not found). Looking at the example below, this process should make a little more sense. For example, the output tells us where each value from 1:15 appears in the vector num.\n\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\n1:15\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n\nmatch(1:15, num)\n\n [1] NA NA  4 NA  3 NA NA NA  6  1  2  7 10 NA NA\n\n\nThe duplicated() function helps us determine if we have seen a value before, while the unique() function returns all values without any duplicated elements.\n\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\nduplicated(num)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\nnum[!duplicated(num)]\n\n[1] 10 11  5  3  9 12 13\n\nunique(num)\n\n[1] 10 11  5  3  9 12 13\n\n\nThe any() and all() functions check whether a logical condition has been met and then output a single logical value. The any() function checks if at least one element meets the criteria, while the all() function checks if every element meets the criteria.\n\nnum\n\n [1] 10 11  5  3 11  9 12  9  9 13\n\nany(num &gt; 10)\n\n[1] TRUE\n\nany(num &gt;= 15)\n\n[1] FALSE\n\nall(num &lt; 10)\n\n[1] FALSE\n\nall(num &lt;= 15)\n\n[1] TRUE\n\n\nThe last thing we will discuss in this lecture is the %in% operator. This operator is useful when we want to check whether values in a vector match any value from a list of possible options. The example below shows why it is beneficial. If we use == c(1, 2), R performs an element-by-element comparison and recycles the shorter vector, which produces incorrect results. Using %in% fixes this by checking whether each element is in the set {1, 2}. This is especially helpful when we want to test for membership in multiple possible values without writing long logical expressions.\n\nx &lt;- c(1, 1, 1, 1, 2, 2, 2, 3, 3, 4)\nx\n\n [1] 1 1 1 1 2 2 2 3 3 4\n\nx[ x == c(1,2)]\n\n[1] 1 1 2\n\nx == c(1,2)\n\n [1]  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\nx %in% c(1,2)\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nx[ x %in% c(1,2)]\n\n[1] 1 1 1 1 2 2 2\n\n\n\n\n\n\n\n\nTry it Out\n\n\n\nEmmit copied his workout log into the vector below and wants to check for repeats. Teach Emmit how to identify any duplicated values. Then using the log vector, show Emmit how he could identify any entries showing \"Walk\" or \"Bike\". Finally, using the vector below describing the lengths of his workout, teach Emmit how to determine if any workouts were longer than 45 minutes and if all the workouts were less than 1 hour.\n\nlog &lt;- c(\"Run\", \"Walk\", \"Walk\", \"Bike\", \"Yoga\", \"Run\", \"Rest\", \"Swim\", \"Swim\", \"Bike\")\ngoal_mins &lt;- c(30, 25, 25, 45, 20, 35, 0, 50, 40)\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  },
  {
    "objectID": "Lecture-2-Strings-and-Text-Processing.html#more-complex-logical-selections",
    "href": "Lecture-2-Strings-and-Text-Processing.html#more-complex-logical-selections",
    "title": "2  Text Processing and Useful R Tools",
    "section": "",
    "text": "Try it Out\n\n\n\nEmmit tracked how many minutes he exercised each day for 11 days using the vector below. He considers a day “good” if his workout was more than 35 minutes AND less than or equal to 80 minutes. Teach Emmit how he can display the values meeting that criteria. He also wants to display the days where he exercised less than 20 minutes OR more than 90 minutes. Finally, he wants to display all days that are NOT greater than or equal to 60 minutes.\n\nmins &lt;- c(12, 40, 75, 95, 18, 62, 35, 81, 0, 90, 55)\n\n\n\nClick to see the solution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Text Processing and Useful R Tools</span>"
    ]
  }
]